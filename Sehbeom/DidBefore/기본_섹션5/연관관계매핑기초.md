# Section5

# 연관관계 매핑 기초

- 객체 <-> 테이블 연관관계의 차이를 이해해야함.
- 객체의 참조(reference) <-> 테이블의 외래 키를 매핑하는 것.
    - 객체의 참조 : reference, class.getTaste.~~.~~. … 이렇게 reference를 토대로 내부에 필요한 것들을 찾아나감.
    - 테이블의 외래키 : Foreign Key로 연결. 외래 키로 연결된 테이블 안에 해당 키 값을 갖고 있는 데이터를 찾음.
    - 이렇게 서로 다른 개념을 매핑하는 것.
- 방향(Direction) : 단방향, 양방향
- 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 연관관계의 주인(Owner) : 객체 양방향 연관관계는 이를 관리하는 주인이 필요하다. 중요하고 어렵다..! JPA 계의 포인터 같은 느낌..!

### 연관관계가 필요한 이유

- “객체 지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.”

### 예제 시나리오

- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있음.
- 회원 : 팀 = N : 1 관계이다.
    - 하나의 팀에 여러 회원이 소속될 수 있다.

<객체를 테이블에 맞춰서 모델링할 경우>

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled.png)

- 테이블에 맞춰서 모델링할 경우, 위 사진과 같이 객체에서도 Member 엔티티에 Team 엔티티와의 연관관계로 teamId 가 들어가게 된다.
- 테이블은 그대로 MEMBER 테이블에 TEAM_ID가 외래키로 들어가고, 이는 TEAM 테이블의 PK인 TEAM_ID와 연결된다.
    - FK를 가진 쪽이 다수가 된다.
    - 테이블에 들어갈 때 서로 다른 MEMBER_ID를 가진 데이터들이 하나의 TEAM_ID 값을 가지며 외래키로 참조하게 되는 것. (서로 같은 팀인 것)
- 이렇게 모델링하게 되면, 객체 지향 방식에서 Reference를 따라 참조하게 되는게 아닌, 그냥 teamId라는 변수 값으로 참조하게 되는 것.
    - 원래 객체 지향 방식에서는 Member 클래스 안에 Team 클래스 객체가 들어가있고, 이를 참조하도록 모델링해야함.
    - 그래야 Team 객체에서 team.getName()… 이런식으로 바로바로 참조가 가능하기 때문!

<테이블 위주 모델링의 문제점(애매한점..?)>

- 위 회원과 팀 예제 코드로 구현
    - 회원 (Member class)
        
        ```java
        package hellojpa;
        
        import javax.persistence.*;
        import java.util.Date;
        
        @Entity
        public class Member {
        
            @Id
            @GeneratedValue
            @Column(name = "MEMBER_ID")
            private Long id;
        
            @Column(name="USERNAME")
            private String username;
        
            @Column(name = "TEAM_ID")
            private Long teamId;
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public void setUsername(String username) {
                this.username = username;
            }
        
            public void setTeamId(Long teamId) {
                this.teamId = teamId;
            }
        
            public Long getId() {
                return id;
            }
        
            public String getUsername() {
                return username;
            }
        
            public Long getTeamId() {
                return teamId;
            }
        
            public Member(){
        
            }
        }
        ```
        
    - 팀 (Team class)
        
        ```java
        package hellojpa;
        
        import javax.persistence.Column;
        import javax.persistence.Entity;
        import javax.persistence.GeneratedValue;
        import javax.persistence.Id;
        
        @Entity
        public class Team {
            @Id @GeneratedValue
            @Column(name = "TEAM_ID")
            private Long id;
        
            @Column(name = "NAME")
            private String name;
        
            public Long getId() {
                return id;
            }
        
            public String getName() {
                return name;
            }
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public void setName(String name) {
                this.name = name;
            }
        }
        ```
        

1. 데이터 저장 과정

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeamId(team.getId()); // 이부분이 상당히 애매함
em.persist(member);

tx.commit();
```

- 위 코드에서 객체 지향 방식으로는 member 객체에 team 객체를 연결할 때, teamId가 아닌 team 자체가 들어가야 더 자연스러움.

1. 데이터 조회 과정

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeamId(team.getId()); // 이부분이 상당히 애매함
em.persist(member);

// 아래 부분이 이상하다.
Member findMember = em.find(Member.class, member.getId());
Long findTeamId = findMember.getTeamId();

Team findTeam = em.find(Team.class, findTeamId);

tx.commit();
```

- findMember에 원하는 회원을 find() 해와서 저장하고, 어느 team에 속해 있는지 알아내기 위한 과정이다.
- 원래 객체 지향에서는 member만 가져와도 어느 team인지 알아볼 때, getTeam() 으로 해당 team 객체 자체를 불러올 수 있어야 함.
- 하지만 테이블 위주 방식에서는 getTeamId() 하고, 받아온 값을 토대로 다시 한번 Team 테이블에 find() 해야 받아올 수 있음.

- 이런 예시들을 보면, 테이블과 객체 사이에는 아래와 같은 큰 간격이 존재한다.
    - 테이블 : 외래 키로 join 해서 연관된 테이블을 찾는다.
    - 객체 : 참조해서 연관된 객체를 찾는다.

### 단방향 연관관계

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%201.png)

- 단방향 연관관계를 적용하면, 위 사진과 같이 이루어진다.
- 앞서 언급한 것과 같이 Member class 안에 Team class와의 연관관계가 teamId가 아닌 team 객체 그 자체로 이어진다.
- 이를 구현하기 위해서는 @ManyToOne, @JoinColumn Annotation을 활용해야 한다.

<구현>

- Member class에서 적용해주면 된다.

```java
...

//    @Column(name = "TEAM_ID")
//    private Long teamId;

    @ManyToOne // JPA에게 해당 객체가 연관관계 매핑임을 알린다. 
    @JoinColumn(name = "TEAM_ID") // DB 상의 어느 Column과 join 되는지 알린다.
    private Team team;

...
```

- 위 코드와 같이 연관관계가 있는 객체에 @ManyToOne, @JoinColumn Annotation 을 걸어주면 된다.
    - @ManyToOne : 다대일(N:1) 관계에서 다(N) 쪽에 걸어주어야 한다. JPA에게 본 객체는 다대일 연관관계에 포함되어 있다는 것을 알림.
    - @JoinColumn : DB 상에 어느 Column과 join 되는지 알린다. 본 예제에서는 Team의 PK 값인 ‘TEAM_ID’와 join 되므로 이를 넘긴다.
        - DB에서 join으로 조회할 때 ~~~join team t on m.team_id == t.team_id ~~ 할때 비교하게 되는 Column을 전달해 주어야 함.

- 이렇게 해두면 아까 위에서 다뤘던 단점들이 모두 해결된다.
1. 데이터 저장 과정

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team); // team 객체를 그대로 넣어주면 된다.
em.persist(member);
```

- 위 코드와 같이 team 객체를 그대로 넣어줄 수 있다.

1. 데이터 조회 과정

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team); // team 객체를 그대로 넣어주면 된다.
em.persist(member);

Member findMember = em.find(Member.class, member.getId());
Team findTeam = findMember.getTeam(); // 여러번 find 할 필요 없이 그냥 객체를 바로 갖고 올 수 있다.
```

- 앞에서 teamId로 또 find() 하고 그럴 필요 없이 그냥 findMember.getTeam() 으로 바로 원하는 객체를 가져올 수 있다.
- findMember를 채울 때, 위 코드에서는 이미 persist() 과정에서 영속성 컨텍스트에 저장해두었기 때문에 따로 쿼리가 날아가지 않는다.
- 만약 위 코드와 달리 영속성 컨텍스트에 없을 경우, findMember 채울 때 teamId를 기준으로 join시켜서 가져오게 된다.
    
    ![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%202.png)
    
    - 위 사진에서 ‘left outer join~~’ 을 보면 알 수 있다.

1. 데이터 수정 과정

```java
Team newTeam = em.find(Team.class, 100L);
findMember.setTeam(newTeam);
```

- 위와 같이 바꾸고 싶은 팀을 가져와 그대로 setTeam() 해주면 알아서 바꿔준다.

### 양방향 연관관계와 연관관계의 주인 (중요, 어려움)

<양방향 연관관계 예제>

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%203.png)

- 단방향 연관관계에서의 예제에서 조금 달라짐 : Team 엔티티에 ‘List members’ 가 추가되었다.
- 목적 : Team을 골랐을 때 그 team에 속해있는 회원들의 목록을 알기 위해.
    - 원래는 member 객체에서 team 객체를 알아내는 것만 가능했다. : member → team : 단방향
    - 하지만 여기서 추가하는 것은 team 객체에서 member 목록을 알아내는 것. : team <-> member : 양방향
- 하지만 위 연관관계 그림을 보면, 테이블은 변한게 없음. 변할 필요가 없기 때문.
    - MEMBER 테이블에 있는 데이터들 중에서 어느 팀에 속해있는지 알아내기 위한 join 가능 : 단방향에서 했던 것.
    - TEAM 테이블에 있는 데이터들 중에서 팀 하나에 소속되어 있는 회원들 목록도 join으로 뽑아낼 수 있음.
    - 애초에 테이블은 PK, FK로 연결되어 있으면 기본적으로 양방향이 되어 있는 것.
- 하지만 JPA의 객체에서는 양방향을 해주기 위해서는 필드를 하나 더 추가해 주어야 한다. (위 그림의 ‘List members’처럼)

<구현>

- Team class

```java
@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    @Column(name = "NAME")
    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>(); // List를 쓸 때는 관례상 ArrayList를 써주어야 한다.

		...
```

- 아까 Member class에서는 @ManyToOne 으로 매핑했다면, 이번에는 @OneToMany 로 매핑한다.
- 이는 member : team = N : 1 관계이기 때문에, N 측에서는 @ManyToOne, 1 측에서는 @OneToMany 를 쓰는 것.
- 그리고 mappedBy 속성을 “team” 를 넣고 있는데, 이는 Member class에서 @ManyToOne 을 걸었던 필드의 이름을 그대로 넣어주면 된다.
    
    ```java
    ...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team; // 여기서 필드 이름을 team으로 했기 때문에 이걸 OneToMany의 mappedBy로 넣어준다.
    ...
    ```
    
- 이렇게 해두고 Main에 아래와 같이 구성해 두면 회원 목록을 바로 찾을 수 있다.

```java
Team team = new Team();
team.setName("TeamA");
em.persist();

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member);

em.flush();
em.clear();

Team findTeam = em.find(Team.class, team.getId());
List<Member> memberList = findTeam.getMembers();

for (Member m : memberList){
		System.out.println("m : " + m.getUsername());
}
```

- 위 코드에서 em.flus(), em.clear() 해주어야 DB에서 깔끔하게 값을 가져와 적용할 수 있다.
- 혹은 특정 회원을 골라 그 회원과 같은 팀에 있는 회원들 목록을 가져오고 싶을 경우, 아래와 같이 해줄 수도 있다.

```java
Team team = new Team();
team.setName("TeamA");
em.persist();

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member);

em.flush();
em.clear();

Member findMember = em.find(Member.class, member.getId());
List<Member> memberList = findMember.getTeam().getMembers();

for (Member m : memberList){
		System.out.println("m : " + m.getUsername());
}

```

- 위 코드의 findMember.getTeam().getMembers() 를 보면, Member→Team→Member 로 왔다갔다 하는 것을 볼 수 있다.
    - 이런 과정이 가능한게 양방향 연관관계 이다.
- 하지만 객체에서는 웬만하면 단방향으로만 이루어지도록 구성하는게 제일 좋다. 양방향 계속 쓰게 되면 신경써야 할게 너무 많아짐.

### mappedBy

- JPA의 멘붕 난이도..!
- 처음에는 이해하기 어려움.
- 양방향 연관관계를 맺을 때, 객체의 방식과 테이블의 방식에 차이가 있다는 것을 이해해야 한다.

### 양방향 연관관계를 맺는 방식의 차이

<객체의 연관관계 : 2개>

- 객체에서 양방향을 맺을 때, **사실 단방향을 2개 넣는 것**이다.
    - 단방향 연관관계를 2개 만들어야 한다.
- 회원 → 팀 : Member class 내에 team 객체를 넣고 연결.
- 팀 → 회원 : Team class 내에 members 객체 리스트를 넣고 연결.
- 결국 양방향을 이어주기 위해서는 **Member class의 team 객체**, **Team class의 members 리스트 두가지 참조를 넣어주어야 한다.**

<테이블의 연관관계 : 1개>

- 테이블에서는 FK 하나만으로 양방향 연관관계가 이어질 수 있다.
- 회원 테이블에 team_id 필드(FK) 하나만 추가했는데도 양방향 관계가 이루어 질 수 있다는 것.
- 회원 → 팀 : 회원 하나 골라서 그 회원이 갖고 있는 team_id 값 기준으로 TEAM 테이블과 join
    
    ```sql
    SELECT * 
    FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
    ```
    
- 팀 → 회원 : 팀 하나 골라서 해당 팀의 PK 값(=team_id) 기준으로 MEMBER 테이블과 join
    
    ```sql
    SELECT *
    FROM TEAM T
    JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
    ```
    
- 결국 양방향을 이어주기 위해 그냥 MEMBER 테이블에 FK로 team_id를 추가해주면 된다.

### 방식의 차이에서 오는 딜레마

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%204.png)

- 객체에서는 양방향 연관관계를 구현하기 위해 단방향 두개를 넣어둔 상태.
    - Member class의 team 객체
    - Team class의 member 객체 리스트
- 하지만 테이블에서는 MEMBER 테이블의 FK (team_id)만 넣어둔 상태.
- 이런 상황에서 MEMBER 테이블의 FK (team_id)는 둘 중 어느 것과 매핑이 되어야 하는가?
    - Member의 team 객체?
    - Team의 member 객체 리스트?
    - 그렇다고 둘 다 매핑을 시킬 순 없음. 둘 중 하나만 매핑시켜줘야함.
- 만약 특정 회원이 팀을 바꿀 경우 (값의 수정이 일어날 경우), 둘 중 어느 것과 매핑하는게 더 효율적인지 굉장히 애매해짐.
    - 사실 MEMBER 테이블에서는 그냥 FK 값만 바꿔주면 됨. 어차피 join할 때는 바뀐 FK 값이 들어가게 되니까.
    - Member의 team과 매핑 : Team의 리스트에는 따로 반영해야 함.
    - Team의 members와 매핑 : Member의 team에 또 따로 반영해줘야함.
    - 둘 중 하나를 선택해야 한다. → **연관관계의 주인(Owner)을 설정해 주어야 한다.**

### 연관관계의 주인(Owner)

<객체에서 양방향 연관관계 매핑 규칙>

- 객체의 두 단방향 관계 중, 하나를 **연관관계 주인**으로 지정.
- **연관관계의 주인만 FK를 관리**할 수 있다. (**등록, 수정**)
- **주인이 아닌 쪽은 읽기만 가능**하다. ⭐️
- 주인은 mappedBy 속성을 쓰지 않는다.
- 주인이 아니면 mappedBy 속성으로 주인을 지정한다.
    - mappedBy가 무언가에 의해 본인이 매핑되었다는 의미.
    - 결국, Member의 team 객체가 본인(Team의 members)을 관리한다는 의미이다.
    - 아까 다음과 같이 mappedBy 속성을 쓴 이유가, Member class의 team 객체를 주인으로 만든 것!
    
    ```java
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
    ```
    
- 위와 같이 Team의 members는 주인이 아니다.
    - 따라서 Team의 members는 읽기만 가능하다. ( = 회원 조회만 가능하다.)
    - Team의 members를 통해 회원을 수정하거나 등록하는 것은 불가능하다.
    - 따라서 특정 팀에 특정 회원을 넣을 때, Member 객체에 team을 지정해야 반영된다.
    - Team 객체의 members 리스트에 백날 회원을 넣어봐야 반영되지 않는다.
    

### 누구를 주인으로?

- **FK가 있는 곳을 주인**으로 정하는게 좋다.
    - 예제에서는 Member가 된다.

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%205.png)

- 위와 같이 어쨌든 MEMBER 테이블에 FK가 있고, 이 테이블은 Member 객체와 매핑되어 있다.
- 그럼 주인을 Member의 team으로 해두고, mappedBy를 Team의 members로 해두는게 좋다.
- 그리고 만약 Team의 members로 주인을 하게 되면, 어쨌든 Team 객체에서 Member 객체를 수정, 등록하게 되는거고, 그럼 Team 객체에서 만든게 MEMBER 테이블로 쿼리가 날아가게 된다. (매우 복잡해진다.)
- 다대일, 일대다 관계에서 결국, **FK를 갖는 쪽은 다(N) 쪽이고, 여기를 주인으로 설정하면 된다.**
- ⭐️ 그냥 쉽게 생각해서 다(N) 쪽( = FK가 있는 쪽)을 주인으로 설정하면 된다. ⭐️

### 양방향 매핑 시, 가장 많이 하는 실수

- 연관관계 주인의 값을 입력하지 않음.

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1"); // team을 설정하지 않음. 즉, 연관관계 주인의 값을 입력하지 않음.

team.getMembers().add(member); // 역방향(주인이 아닌)만 연관관계 설정함.

em.persist(member);
```

- 위 예시와 같이 연관관계 주인(Member의 team)은 까먹고 설정 안하고 주인이 아닌 역방향(Team의 members)에만 추가해놓고 persist()함.
- 이러면 역방향은 등록, 수정이 안되기 때문에 애초에 쿼리에 반영 자체를 안함. 그냥 조회만 하는 것.
- 이에 따라 MEMBER 테이블의 team_id 컬럼은 null 값이 되어버림.
- 따라서 아래와 같이 꼭 연관관계 주인을 설정해주어야 한다.
    - 사실 연관관계 주인만 설정해줘도 된다. 역방향은 어차피 조회용이기 때문에 해봤자 DB에 반영 자체가 안됨.
    - 하지만 꼭 역방향도 설정을 해줘야 함. 안그러면 문제가 발생할 수 있다.

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member); // team을 설정하지 않음. 즉, 연관관계 주인의 값을 입력하지 않음.

team.getMembers().add(member); // 역방향(주인이 아닌)만 연관관계 설정함.
```

### 연관관계 주인만 설정하고 역방향은 설정 안해주면 발생하는 문제점.

- 원래는 연관관계 주인만 설정해도 DB에 반영되고 나면 역방향을 출력했을 때 알아서 다 가져옴.
- 하지만 역방향도 설정해주는게 객체 지향 방식에 더 적합하고, 설정 안해주면 문제도 발생한다.
    - 객체 지향적으로 생각해보면, member 객체에도 설정하고, team 객체에도 설정하는게 올바르다.

<1. 첫번째 문제점 : 1차 캐시 관련>

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member);

em.flush();
em.clear();

Team findTeam = em.find(Team.class, team.getId());
List<Member> memberList = findTeam.getMembers();

for (Member m : memberList) {
    System.out.println("m : "+m.getUsername());
}
```

- 위 코드와 같이 member 객체에서만 team을 설정해주고(주인만 설정), team의 members는 설정해주지 않을 경우, em.flush(), em.clear() 이후 과정을 해보면 members가 잘 출력된다.
    - findTeam을 채울 때 find()에서 TEAM 테이블에 select 쿼리 나감.
    - memberList 채울 때 findTeam.getMembers() 에서 TEAM, MEMBER 테이블 join하는 쿼리 나감.
    
    ![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%206.png)
    

- 하지만 이는 em.flush, em.clear 때문에 가능한 것. 이게 없으면 getMembers()에서 아무것도 안나온다.

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member); // team을 설정하지 않음. 즉, 연관관계 주인의 값을 입력하지 않음.

// em.flush();
// em.clear();

Team findTeam = em.find(Team.class, team.getId());
List<Member> memberList = findTeam.getMembers();

for (Member m : memberList) {
    System.out.println("m : "+m.getUsername());
}
```

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%207.png)

- 이런 현상은 아래와 같은 과정으로 발생한다.
    1. team, member 객체 생성 후 persist() 각각 호출 됨. 하지만 DB에 바로 쿼리가 날아가진 않음.
        
        (team의 members는 비어있음)
        
    2. DB로부터 PK 값만 받아서 영속성 컨텍스트에 저장됨.
        
        (역시 team의 members는 비어있음)
        
    3. 그 다음 findTeam을 채울 때, find()가 호출됨.
    4. DB에 select 쿼리를 날리는게 아닌, 1차 캐시에서 조회한 후 가져옴.
        
        (즉, 그냥 team 객체를 그대로 가져오는 것. members는 역시 비어있음.)
        
    5. 따라서 getMembers() 해도 그냥 비어있는 리스트를 가져오는 것.
- 이렇게 DB에 반영되기 전에 다시 조회해서 활용할 경우, 1차 캐시에서 조회하기 때문에 원하는 결과가 안나올 수 있다.
- 따라서 아래와 같이 역방향도 설정해주어야 한다.

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member); // team을 설정하지 않음. 즉, 연관관계 주인의 값을 입력하지 않음.

team.getMembers().add(member);
// em.flush();
// em.clear();

Team findTeam = em.find(Team.class, team.getId());
List<Member> memberList = findTeam.getMembers();

for (Member m : memberList) {
    System.out.println("m : "+m.getUsername());
}
```

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%208.png)

- 위 사진에서 team, member의 insert 쿼리가 나가기 전, 잘 출력되는 것을 확인할 수 있다.

<2. 테스트 케이스 작성 시>

- 나중에 테스트 케이스를 작성하게 될 텐데, 이 때는 JPA 기능이 제한됨.
- 따라서 객체 한쪽만 설정하게 되면, 다른 한쪽이 비어있게 돼서 문제가 생길 수 있다.

- ⭐️ **따라서 양방향 매핑할 때는 연관관계 주인과 역방향 양쪽 다 값을 바로바로 넣어줘야 한다.** ⭐️

### 양방향 연관관계 주의

- ⭐️ **순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자!!** ⭐️
- 하지만 아래와 같이 일일이 직접 작성하면 깜빡할 수가 있다.

```java
...

member.setTeam(team);
em.persist(member);

team.getMembers().add(member);
...
```

- 따라서 다음과 같이 연관관계 주인 측, 혹은 역방향 측 둘 중 하나에 “**연관관계 편의 메소드**”를 설정하면 좋다.
    - 아예 Member의 setTeam() 함수에 Team의 members에도 추가하는 로직을 추가하는 것이다.
    - 그리고 이렇게 특정 로직을 추가한 경우, 함수 이름을 단순히 ‘setTeam()’으로 짓는게 아닌, ‘changeTeam()’ 처럼 좀더 유별나게 짓는게 코드 관리에 더 좋다.
    - 기존 setTeam()
    
    ```java
    public void setTeam(Team team){
    		this.team = team;
    }
    ```
    
    - changeTeam()
    
    ```java
    public void changeTeam(Team team){
    		this.team = team;
    		team.getMembers().add(this);
    }
    ```
    
    → 이처럼 아예 주인 측에서 설정할 때 역방향도 한번에 해버리는 것이다.
    
    → 이미 존재해 있는지 여부 확인 등 validation이 필요하면 상황에 따라 추가해주면 된다.
    
    - 혹은 역방향 쪽에서 정의해줘도 된다.
    - Team 엔티티 측에서 아래와 같이 ‘addMember()’를 만든다.
    
    ```java
    public void addMember(Member member){
    		member.setTeam(this);
    		this.members.add(member);
    }
    ```
    
    - **중요한건 한쪽에서만 걸어주는 것이다. 안그러면 무한루프에 빠질 수도 있다.**

- 또한, 양방향 매핑 시, 무한루프를 조심해야한다. (ex. toString() 함수 정의, lombok, JSON 생성 라이브러리 등)
    - 보통 개발할 때, 객체의 내용을 편하게 보기 위해 다음과 같이 ‘toString()’ 함수를 정의하기도 한다.
        - Team의 toString()
        
        ```java
        @Override
        public String toString(){
        		return "Team{" +
        						"id=" + id +
        						", name='" + name + '\'' +
        						", members=" + members + 
        						'}';
        }
        ```
        
        - Member의 toString()
        
        ```java
        @Override
            public String toString() {
                return "Member{" +
                        "id=" + id +
                        ", username='" + username + '\'' +
                        ", team=" + team +
                        '}';
            }
        ```
        
    - 이런 toString() 함수는, 다음과 같이 쓸 수 있다.
        
        ```java
        System.out.println("findTeam : " + findTeam);
        ```
        
        - 이렇게 쓰면 Team class에서 정의된 toString() 함수에 맞춰 findTeam 객체의 내용이 출력되는 것이다.
    - 코드를 보면, Team에서는 members에서 member를 출력하고 있고, Member에서는 team을 출력하고 있다.
    - 즉, 만약 Member의 toString()이 호출되면, team을 출력할 때 Team의 toString()이 출력되고, 여기서는 members를 또 출력한다. 그럼 또 Member의 toString()이 호출되고 …
    - 이에따라 무한루프를 돌게 된다.
    - 보통 lombok 같은 라이브러리에서 toString()을 자동으로 생성해주곤 하는데, 그러면 이렇게 무한루프가 돌 수 있는 것이다.
    - 그 외에도 엔티티 내용을 JSON으로 뽑아주는 JSON 생성 라이브러리를 쓸 때도 이런 현상이 발생할 수 있다.
        - Spring 쓸 때, Controller에서 엔티티를 JSON 형태로 반환하도록 하는 과정.

### 무한루프 해결

- lombok 처럼 toString()을 자동으로 생성해주는건 웬만하면 쓰지말고, 쓰게 돼도 적절히 수정해서 써라.
- JSON 생성 라이브러리 : 아예 Controller에서 엔티티를 반환하지 마라.
    - 무한루프가 발생할 수 있는 문제가 있다.
    - 엔티티는 DTO로 변환해서 Controller에서 반환하는게 좋다.

### 양방향 매핑 정리

- 단방향 매핑만으로도 이미 연관관계 매핑은 끝난거다.
    - 웬만하면 설계 과정에서 양방향 개념은 생각하지 않는게 제일 좋다.
    - 최대한 단방향 연관관계만 적용하도록 설계하는게 좋다.
- 양방향 매핑은 그냥 역방향으로 조회(객체 그래프 탐색, ~~.~~().~~() …) 할 수 있는 기능이 추가된 것이다.
- 나중에 JPQL에서 역방향으로 탐색할 일이 많다.
- 우선 단방향 매핑을 잘 하고, 양방향은 필요할 때 추가해도 된다.
    - 어차피 테이블에는 영향을 주지 않는다.
    - 아까 위에서 양방향 매핑 내용 처음 들어갈 때, 객체에 필드가 추가되고 Annotation만 추가된거지, 사실 테이블에서는 아무 변화도 없었다.
- ⭐️ **설계 과정에서는 무조건 단방향으로 다 끝내버리는게 좋다. 그리고 그 이후에 실제 개발 과정에서 양방향 매핑에 대해 고민해도 늦지 않다. 어차피 테이블은 그대로니까.** ⭐️

### 연관관계 주인을 정하는 기준

- 절대 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안된다. (할 수는 있지만 너무 복잡해진다.)
- ⭐️ **연관관계의 주인은 외래 키(FK)의 위치를 기준으로 선택해야 한다.** ⭐️
    - 이렇게 해놔도 뭔가 다른 상황이 있으면 아까 다뤘던 ‘연관관계 편의 메소드’ 처럼 다른 함수를 구현해서 그걸 쓰면 된다.

### 실전예제2 - 연관관계 매핑 적용

- 이전과 테이블 구조는 완전 동일.

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%209.png)

- 객체에서는 참조 구조를 사용하도록 변경.

![Untitled](Section5%20c0e73d744c544dbdb2479fad19857962/Untitled%2010.png)

- ⭐**중요한건 일단 단방향부터 한 후, 양방향은 필요하면 추가하는 식으로 개발이 진행되어야 함.**⭐
    
    (위 예제에서도 Order의 orderItems 리스트는 필요할 수 있지만, Member의 orders 리스트는 필요 없음)
    

**<단방향 연관관계 적용>**

- Order의 FK(member)
    - member 객체 추가 코드
        
        ```java
        package jpabook.jpashop.domain;
        
        import javax.persistence.*;
        import java.time.LocalDateTime;
        import java.util.ArrayList;
        import java.util.List;
        
        @Entity
        @Table(name="ORDERS")
        public class Order {
        
            @Id
            @GeneratedValue
            @Column(name="ORDER_ID")
            private Long id;
        
            @ManyToOne
            @JoinColumn(name = "MEMBER_ID")
            private Member member;
        
            private LocalDateTime orderDate;
        
            @Enumerated(EnumType.STRING)
            private OrderStatus status;
        
            public Long getId() {
                return id;
            }
        
            public Member getMember() {
                return member;
            }
        
            public List<OrderItem> getOrderItems() {
                return orderItems;
            }
        
            public LocalDateTime getOrderDate() {
                return orderDate;
            }
        
            public OrderStatus getStatus() {
                return status;
            }
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public void setMember(Member member) {
                this.member = member;
            }
        
            public void setOrderItems(List<OrderItem> orderItems) {
                this.orderItems = orderItems;
            }
        
            public void setOrderDate(LocalDateTime orderDate) {
                this.orderDate = orderDate;
            }
        
            public void setStatus(OrderStatus status) {
                this.status = status;
            }
        }
        ```
        
    - 본인이 다수(N, FK)인 상황이므로, @ManyToOne 어노테이션과 @JoinColumn 어노테이션을 활용함.
    - JoinColumn에 테이블 상에서 FK에 해당하는 컬럼 명을 넣음.
    - 테이블처럼 Id 필드를 추가하는게 아닌, Member 객체 자체를 추가함.
    - 필요하면 SETTER, GETTER 생성

- OrderItem의 FK(item, order)
    - item, order 객체 추가 코드
        
        ```java
        package jpabook.jpashop.domain;
        
        import javax.persistence.*;
        
        @Entity
        public class OrderItem {
            @Id @GeneratedValue
            @Column(name = "ORDER_ITEM_ID")
            private Long id;
        
            @ManyToOne
            @JoinColumn(name="ORDER_ID")
            private Order order;
        
            @ManyToOne
            @JoinColumn(name="ITEM_ID")
            private Item item;
        
            private Integer orderPrice;
        
            private Integer count;
        
            public Long getId() {
                return id;
            }
        
            public Order getOrder() {
                return order;
            }
        
            public Item getItem() {
                return item;
            }
        
            public Integer getOrderPrice() {
                return orderPrice;
            }
        
            public Integer getCount() {
                return count;
            }
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public void setOrder(Order order) {
                this.order = order;
            }
        
            public void setItem(Item item) {
                this.item = item;
            }
        
            public void setOrderPrice(Integer orderPrice) {
                this.orderPrice = orderPrice;
            }
        
            public void setCount(Integer count) {
                this.count = count;
            }
        }
        ```
        
    - 여기도 동일하게 @ManyToOne, @JoinColumn 어노테이션을 활용하며, 각각 @JoinColumn 어노테이션에 테이블의 FK 에 해당하는 컬럼 이름을 넣는다.
    - 여기서도 객체 자체를 추가함. SETTER, GETTER 추가

**<양방향 연관관계 적용>**

- 다시한번 언급하지만, 양방향은 필요하면 나중에 추가해도 되는 것. JPQL과 같이 더 좋은 대안이 있으면 그걸 쓰는게 좋음. **일단 단방향 먼저 완벽하게 해두는게 중요하다.**

- Member 클래스의 orders 리스트
    - orders 리스트 추가
        
        ```java
        package jpabook.jpashop.domain;
        
        import javax.persistence.*;
        import java.util.ArrayList;
        import java.util.List;
        
        @Entity
        public class Member {
        
            @Id @GeneratedValue(strategy = GenerationType.AUTO)
            @Column(name="MEMBER_ID")
            private Long id;
        
            private String name;
        
            private String city;
        
            private String street;
        
            private String zipcode;
        
            @OneToMany(mappedBy = "member")
            private List<Order> orders = new ArrayList<>();
        
            //GETTER, SETTER
            public Long getId() {
                return id;
            }
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public String getName() {
                return name;
            }
        
            public void setName(String name) {
                this.name = name;
            }
        
            public String getCity() {
                return city;
            }
        
            public List<Order> getOrders() {
                return orders;
            }
        
            public void setCity(String city) {
                this.city = city;
            }
        
            public String getStreet() {
                return street;
            }
        
            public void setStreet(String street) {
                this.street = street;
            }
        
            public String getZipcode() {
                return zipcode;
            }
        
            public void setZipcode(String zipcode) {
                this.zipcode = zipcode;
            }
        
            public void setOrders(List<Order> orders) {
                this.orders = orders;
            }
        }
        ```
        
    - 1:N 중에서 1에 해당하므로 @OneToMany 어노테이션을 활용하고, ‘mappedBy’ 속성으로 N에 해당하는 Orders 클래스의 member 필드 명을 넣음.
    - JPA 관례 상 new ArrayList<>() 로 ArrayList를 활용함.
    - Orders의 member 객체 SETTER를 연관관계 편의 메소드로 설정
        - 원래 setMember
        
        ```java
            public void setMember(Member member) {
                this.member = member;
            }
        ```
        
        - Member class의 orders 리스트에도 추가하도록 연관관계 편의 메소드로 바꿈
        
        ```java
        		public void setMemberAndAddToOrdersList(Member member) {
                this.member = member;
                member.getOrders().add(this);
            }
        ```
        
- Order 클래스의 orderItems 리스트
    - orderItems 리스트 추가
        
        ```java
        package jpabook.jpashop.domain;
        
        import javax.persistence.*;
        import java.time.LocalDateTime;
        import java.util.ArrayList;
        import java.util.List;
        
        @Entity
        @Table(name="ORDERS")
        public class Order {
        
            @Id
            @GeneratedValue
            @Column(name="ORDER_ID")
            private Long id;
        
            @ManyToOne
            @JoinColumn(name = "MEMBER_ID")
            private Member member;
        
            @OneToMany(mappedBy = "order")
            private List<OrderItem> orderItems = new ArrayList<>();
        
            private LocalDateTime orderDate;
        
            @Enumerated(EnumType.STRING)
            private OrderStatus status;
        
            public Long getId() {
                return id;
            }
        
            public Member getMember() {
                return member;
            }
        
            public List<OrderItem> getOrderItems() {
                return orderItems;
            }
        
            public LocalDateTime getOrderDate() {
                return orderDate;
            }
        
            public OrderStatus getStatus() {
                return status;
            }
        
            public void setId(Long id) {
                this.id = id;
            }
        
            public void setMemberAndAddToOrdersList(Member member) {
                this.member = member;
                member.getOrders().add(this);
            }
        
            public void setOrderItems(List<OrderItem> orderItems) {
                this.orderItems = orderItems;
            }
        
            public void setOrderDate(LocalDateTime orderDate) {
                this.orderDate = orderDate;
            }
        
            public void setStatus(OrderStatus status) {
                this.status = status;
            }
        }
        ```
        
    - 동일하게 @OneToMany 어노테이션과 mappedBy 속성 활용. mappedBy는 반대측에 해당하는 OrderItem 클래스 내 order 필드명 넣음
    - ArrayList 활용
    - OrderItem의 order 객체 SETTER를 연관관계 편의 메소드로 설정
        - 원래 setOrder
        
        ```java
        		public void setOrder(Order order) {
                this.order = order;
            }
        ```
        
        - Order class의 orderItems 리스트에도 추가하도록 수정
        
        ```java
        		public void setOrderAndAddToOrderItemList(Order order) {
                this.order = order;
                order.getOrderItems().add(this);
            }
        ```
        
    

**<테스트 - JpaMain 구현>**

- JpaMain.java
    
    ```java
    package jpabook.jpashop;
    
    import jpabook.jpashop.domain.*;
    
    import javax.persistence.EntityManager;
    import javax.persistence.EntityManagerFactory;
    import javax.persistence.EntityTransaction;
    import javax.persistence.Persistence;
    
    public class JpaMain {
        public static void main(String[] args) {
            EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("jpashop");
            EntityManager entityManager = entityManagerFactory.createEntityManager();
            EntityTransaction entityTransaction = entityManager.getTransaction();
    
            entityTransaction.begin();
            try {
                Member oneMember = new Member();
                oneMember.setName("member1");
                oneMember.setCity("Incheon");
                oneMember.setStreet("Inharo97");
                oneMember.setZipcode("22207");
                entityManager.persist(oneMember);
    
                Item oneItem = new Item();
                oneItem.setName("item1");
                oneItem.setPrice(1000);
                oneItem.setStockQuantity(10);
                entityManager.persist(oneItem);
    
                Order oneOrder = new Order();
                oneOrder.setMemberAndAddToOrdersList(oneMember);
                oneOrder.setStatus(OrderStatus.ORDER);
                entityManager.persist(oneOrder);
    
                int countOfItem = 10;
                OrderItem oneOrderItem = new OrderItem();
                oneOrderItem.setItem(oneItem);
                oneOrderItem.setOrderAndAddToOrderItemList(oneOrder);
                oneOrderItem.setOrderPrice(oneItem.getPrice() * countOfItem);
                oneOrderItem.setCount(countOfItem);
                entityManager.persist(oneOrderItem);
    
                entityManager.flush();
                entityManager.clear();
    
                Member findMember = entityManager.find(Member.class, oneMember.getId());
    
                for(Order o : findMember.getOrders()){
                    System.out.println("Order Number " + o.getId() + "'s Item List");
                    for(OrderItem oi : o.getOrderItems()){
                        System.out.println("Ordered Item Name : "+oi.getItem().getName());
                    }
                }
    
                entityTransaction.commit();
            } catch (Exception e) {
                entityTransaction.rollback();
            } finally {
                entityManager.close();
            }
    
            entityManagerFactory.close();
        }
    
    }
    ```
    
- Member, Item 객체 생성 후 Order, ItemOrder 객체 생성 및 등록, flush, clear 수행
- find() 한 데이터 findMember 객체에 저장  후, 해당 객체로부터 Order - OrderItem - Item 까지 이어져 결국 주문한 Item의 이름이 출력되도록 설정.
    - 결국 find() 함수 한번으로 Member - Order - OrderItem - Item 까지 쭉 이어짐.