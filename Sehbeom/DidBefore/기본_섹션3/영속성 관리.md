# 영속성 관리 - 내부 동작 방식

JPA에서 가장 중요한 2가지 

- 객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping)
    - JPA 객체와 DB 사이의 매핑 작업
- 영속성 컨텍스트
    - JPA가 내부에서 동작하는 방식

## 영속성 컨텍스트

### 엔티티 매니저 팩토리와 엔티티 매니저

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled.png)

- 웹 어플리케이션을 만든다고 할 때, 우선 EntityManagerFactory가 생성됨.
- 이후 EMF에서 고객의 요청이 들어올 때마다 EntityManager를 생성해서 요청을 수행함.
- EM은 내부에 정의된 Connection을 활용하여 DB와의 소통 수행.

### 영속성 컨텍스트

- JPA를 이해하는데 가장 중요한 용어
- “엔티티를 영구 저장하는 환경” 이라는 뜻
- EntityManager.persist(entity); : 단순히 DB에 저장하는게 아닌, 영속성 컨텍스트 내에 영구히 저장한다는 의미.

### 엔티티 매니저? 영속성 컨텍스트?

- 영속성 컨텍스트는 논리적인 개념이다.
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근하는 것.
- 엔티티 매니저를 하나 생성하면 영속성 컨텍스트도 하나 생기며 1:1로 이어짐.

### 엔티티의 생명주기

- 비영속 (new/transient) : 영속성 컨텍스트와 관계 없음. 새로운 상태.
- 영속 (managed) : 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태

### 비영속 상태

- JPA와 전혀 관계없이 객체만 선언해 둔 상태

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

- 위 코드와 같이 그냥 클래스 만들고 객체만 생성해 둔 상태

### 영속 상태

- 엔티티 매니저의 persist() 함수를 통해 영속 컨텍스트에 집어넣은 상태.

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
EntityManger em = emf.createEntityManager();
em.getTransaction().begin();

em.persist(member);
```

- 위 “em.persist(member)” 처럼 EntityManager의 persist() 함수로 객체를 영속 컨텍스트 내로 집어넣음.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%201.png)

- 영속 상태가 됨으로 인해 영속 컨텍스트의 관리를 받게 됨.
- persist() 한다고 바로 DB에 쿼리가 날아가진 않음.
- DB에 쿼리가 날아가는건 Transaction의 commit() 과정에서 날아감.

### 준영속 상태, 삭제 상태

- 준영속 : 영속 컨텍스트에서 분리시킨 상태.

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();

em.persist(member);
em.detach(member);
```

- 위 코드와 같이 persist() 이후 commit() 하기 전에 바로 detach() 할 경우, DB에 반영되지 않음. commit() 하기 전에 영속성 컨텍스트에서 분리되었기 때문.

- 삭제 : 객체를 삭제한 상태. 아예 삭제함.

```java
em.remove(member);
```

### 영속성 컨텍스트의 이점

- 영속성 컨텍스트 : 애플리케이션과 DB 사이에 ‘영속성 컨텍스트’ 라는 중간 계층이 하나 더 있는 것.
    - 버퍼링, 캐싱 등의 이점을 누릴 수 있음.
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

### 엔티티 조회, 1차 캐시

- 영속성 컨텍스트 내부에 1차 캐시가 존재함. (영속성 컨텍스트 자체를 1차 캐시라고 봐도 무방함. 다르긴 하지만.)

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%202.png)

- persist() 함수를 통해 영속 상태가 되면 위 사진과 같이 1차 캐시에 담기게 됨.
- 여기서 @id 는 매핑 과정에서 설정한 PK값이 되고, Entity는 객체 자체가 된다. 따라서 @id와 member가 들어가게 됨.
- 이렇게 1차 캐시가 있음에 따른 이점은 아래와 같다.

```java
Member member = new Member();
member.setId(101L);
member.setUsername("HelloJPA");

...

// 1차 캐시에 저장됨. 영속 상태
em.persist(member);

// DB에서 조회하기 전, 1차 캐시에서 먼저 조회함.
Member findMember = em.find(Member.class, 101L);

```

- 데이터를 조회하는 과정에서, find() 함수가 쓰이면 바로 DB에서 찾는게 아닌, 1차 캐시에서 먼저 조회를 수행한다.
- 1차 캐시 내에 있을 경우, 바로 반환될 수 있음.
- 실제로 위 코드와 유사하게 실행해 보면,

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%203.png)

- select 쿼리가 안나가는걸 볼 수 있다.

- 만약 1차 캐시에 없을 경우, 아래와 같은 과정을 수행하게 됨.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%204.png)

- 위 사진과 같이 1차 캐시에 존재하지 않은 데이터 “member2”를 조회할 경우, DB에서 조회를 수행함.
- DB에서 찾은 데이터를 1차 캐시에 먼저 저장하고 반환하게 됨.
- 그럼 이후에 또 member2를 조회하게 되면 좀 더 빠르게 조회할 수 있다.
- 앞서 수행한걸 이어서 해보면

```java
Member findMember1 = em.find(Member.class, 101L);
Member findMember2 = em.find(Member.class, 101L);
```

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%205.png)

- 위 사진과 같이 find() 함수는 2번 쓰였지만 select 문은 한번만 나가는걸 확인할 수 있다.
- 이는 findMember1에 대한 쿼리이고, findMember2는 1차 캐시에서 찾아서 바로 가져오기 때문!

- 하지만 이런 이점이 다이나믹한 결과를 가져오진 않음.
    - 보통 EntityManager는 고객 요청 하나에 대해 생성되고 폐기되기 때문에, 폐기되면 1차 캐시도 없어짐.
    - 즉, 찰나의 순간에 좀 더 이점을 갖는 것.
    - 여러 고객의 요청에 대해 캐싱하는건 2차 캐시 과정에서 이루어질 수 있음.

### 영속 엔티티의 동일성 보장

- 영속 엔티티의 == 비교를 보장해준다.

```java
Member findMember1 = em.find(Member.class, 101L);
Member findMember2 = em.find(Member.class, 101L);

System.out.println("result = " + (findMember1 == findMember2));
```

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%206.png)

- 마치 Java의 컬렉션 내에서 동일한 값을 꺼내와서 비교한 것과 같은 효과를 나타냄.
- 1차 캐시가 없으면 이런식으로 동일성이 보장되기 어려움.
- 같은 트랜잭션 내에서 실행되어야 동일성이 보장될 수 있음.

### 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연

- persist() 함수에서는 DB에 SQL을 보내지 않고 영속성 컨텍스트 1차 캐시 내에 계속 쌓아둠.
- 그러다가 commit() 하는 순간 SQL을 보낸다.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%207.png)

- 첫번째 persist()를 수행하면 먼저 객체를 1차 캐시에 저장함.
- 그리고 동시에 insert 쿼리를 생성해서 ‘쓰기 지연 SQL 저장소’ 에 쌓아 둠.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%208.png)

- 두번째도 동일하게 1차 캐시에 넣어놨다가 SQL 저장소에 쌓아둠.
- 여기까지도 DB와의 소통은 없음.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%209.png)

- 계속 쌓아두다가 transaction commit 하는 순간 flush 하면서 commit 되고, 쌓아둔 SQL문이 날아감.
- 본 기능을 통해 버퍼링 효과를 기대할 수 있다. persist 할 때마다 보내기보다 몇개 모아뒀다가 한번에 다 보내기가 가능.

### 엔티티 수정 - 변경 감지(Dirty Checking)

- JPA는 Java의 컬렉션, 리스트에 저장되어 있는 값을 쓰듯이 객체를 쓸 수 있도록 하는데 목적이 있음.
- 이에 따라 find() 로 조회한 데이터를 Java 객체에 넣어두고, 넣어둔 객체 내용을 바꾸고 commit() 하면 알아서 변경된 값을 DB에 반영해줌.
- id 150의 데이터가 DB에 저장되어 있고, name은 “A”라고 저장되어 있을 경우,

```java
Member member = em.find(Member.class, 150L);
member.setName("ZZZZZ");

// 필요할 것 같지만 필요하지 않다. 오히려 쓰면 안됨.
//em.persist(member);

tx.commit();
```

- 위 코드와 같이 조회한 데이터를 member 객체에 넣어놓고, 객체 내에서 수정만 했을 뿐인데 DB에 그대로 반영된다.
- 그냥 리스트 인덱스 값 바꾸듯이 DB 내용을 바꿀 수가 있는 것.
- 이 기능은 commit() 과정에서 알아볼 수 있다.

![Untitled](%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%2083910412267e471e8e2da49ca9c3a842/Untitled%2010.png)

- 먼저 영속 컨텍스트 내 1차 캐시에 처음 데이터가 추가될 때, 처음 모습을 스냅샷으로 기록해둠.
- 이후, JPA는 commit() 할 때 ‘flush()’ 가 호출된다. (flush는 후에 다룸.)
- 기존에 1차 캐시에 저장되어 있는 엔티티 내용 스냅샷과 현재 값을 비교함.
- 스냅샷 내용과 다를 경우, UPDATE 쿼리를 저장소에 추가하고 DB에 날림.

### 엔티티 삭제

- 삭제도 동일한 과정으로 commit() 시점에 DB에 전달된다.

```java
Member memberA = em.find(Member.class, "memberA");

em.remove(memberA);
```

## 플러시

- 영속성 컨텍스트의 변경내용을 DB에 반영 (영속성 컨텍스트 내용과 DB 내용을 맞추는 작업). 쿼리를 날려준다.
- tx.commit() 시 자동으로 플러시가 수행된다.

(플러시가 발생한다고 commit되는건 아니고, 플러시 과정 다 수행되고 난 후에 실제 commit 됨)

### 플러시 발생 시 나타나는 일들

- 변경 감지
- 수정된 엔티티에 대한 SQL을 ‘쓰기 지연 SQL 저장소’에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송. (등록, 수정, 삭제 쿼리)
- **플러시를 한다고 1차 캐시 내용이 모두 지워지는건 아님.** 그냥 쓰기 지연 SQL 저장소에 있는 내용을 DB로 보내고, 반영하는 과정인 것.

### 영속성 컨텍스트를 플러시 하는 방법

- 직접 호출 : em.flush()
    - tx.commit() 하기 전에 바로 DB에 반영해야 하는 경우, 직접 호출할 수 있음.
    
    ```java
    Member member = new Member(200L, "member200");
    em.persist(member)
    em.flush();
    ...
    tx.commit();
    ```
    
- 트랜잭션 커밋 : 플러시 자동 호출
- JPQL 쿼리 실행 : 플러시 자동 호출
    - 만약 JPQL 쿼리 실행 시 플러시가 자동으로 호출되지 않을 경우, 문제가 발생할 수 있음.
    
    ```java
    em.persist(memberA);
    em.persist(memberB);
    em.persist(memberC);
    
    ...
    //중간에 JPQL 실행
    query = em.createQuery("select m from Member m", Member.class);
    List<Member> members = query.getResultList();
    ```
    
    - 위 코드에서 만약 JPQL을 실행할 때, 플러시 되지 않으면, memberA, B, C 가 불러와지지 않음. : 문제될 수 있음.
    - 따라서 기본적으로 JPA에서는 이런식의 문제를 발생시키지 않기 위해 JPQL이 실행될 때는 바로바로 플러시 시켜서 DB에 반영한 후 JPQL을 수행함.
    - 따라서 위 코드는 memberA,B,C가 모두 불러와 질 수 있음.

### 플러시 모드 옵션

- em.setFlushMode(FlushModeType.COMMIT)
- FlushModeType.AUTO : default값. 커밋이나 쿼리 실행할 때 플러시
- FlushModeType.COMMIT : 커밋할 때만 플러시.
    - 위 JPQL 예시에서와 같이, 만약 JPQL 쿼리를 날려도 플러시가 되지 않도록 하려면 플러시 모드 옵션을 COMMIT으로 하면 된다.

### 플러시 특징

- 영속성 컨텍스트를 절대 비우지 않음.
- 영속성 컨텍스트의 변경 내용을 DB와 동기화 시켜주는 작업이라고 생각하면 됨.
- ‘트랜잭션’ 이라는 작업 단위가 중요하다 → 커밋 직전에만 동기화 하면 된다.
    - 뭘 하든 트랜잭션이라는 단위가 중요하기 때문에 그냥 커밋 직전에만 동기화 해주면 된다.

## 준영속 상태

- 특정 객체가 ‘영속’ 상태가 되는 경우?
    - em.persist() 로 영속 상태로 만드는 경우
    - em.find()로 조회했는데 영속 컨텍스트에 없는 경우, 해당 객체를 영속 컨텍스트에 올림 : 영속 상태가 됨.
- ‘준영속’ 상태?
    - 영속 상태였던 객체가 영속 컨텍스트에서 벗어난 상태.
    - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 되는 것. 빼버리는 것.
    - 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음.
    
    ```java
    Member member = em.find(Member.class, 150L);
    member.setName("AAAAA");
    
    em.detach(member);
    
    tx.commit();
    ```
    
    - 위 코드의 경우, 원래는 find로 가져오면 영속 컨텍스트에 올라가고, 내용을 수정하면 commit() 과정의 플러시로 인해 DB에 변경 내용이 반영되어야 함.
    - 하지만 em.detach()로 해당 객체를 영속 컨텍스트에서 빼버렸기 때문에 변경 내용이 DB에 반영되지 않음. (SQL문이 전달되지 않음)

### 준영속 상태로 만드는 방법

- em.detach(entity) : 특정 객체를 골라서 빼낼 수 있음.
- em.clear() : 영속 컨텍스트 내 모든 객체를 빼버림.
- em.close() : 영속 컨텍스트를 아예 종료시켜버림. 아예 객체가 관리되지 않음.