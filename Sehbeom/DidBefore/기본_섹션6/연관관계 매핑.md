# 다양한 연관관계

연관관계 종류

(앞에 붙은게 연관관계 주인인 것. 다대일에서는 다 쪽이, 일대다에서는 일 쪽이 연관관계 주인. 나머지도 동일.)

- 다대일
- 일대다
- 일대일
- 다대다

### 다대일 단방향

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled.png)

- 앞서 다룬 연관관계 기초와 동일한 내용
- 가장 많이 사용되는 연관관계
- 다대일의 반대는 일대다
- 위 예시에서 MEMBER 테이블에 FK가 있고 다 쪽이므로 Member class의 team 객체 필드가 연관관계 주인이 됨.
- @ManyToOne 으로 매핑
- @JoinColumn 에 테이블의 FK 컬럼 이름 전달

```java
@ManyToOne
@JoinColumn(name = "TEAM_ID")
private Team team;
```

### 다대일 양방향

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%201.png)

- 연관관계 기초와 동일한 내용
- 외래키(FK)가 있는 쪽이 연관관계 주인.
- 다대일 단방향 매핑 그대로. 하지만 일 쪽에서도 조회가 가능함. (조회만 가능함)
- 아래와 같이 일 쪽에 @OneToMany 추가 및 mappedBy 속성에 다 쪽의 연관관계 주인 필드명 전달

```java
@OneToMany(mappedBy = "team")
private List<Member> members = new ArrayList<>();
```

### 일대다 단방향

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%202.png)

- 권장하진 않음. 하지만 이렇게 개발해야할 수도 있으니 방법은 알고 있는게 좋음.
- 일 쪽의 필드가 연관관계 주인이 됨.
- 위 예시를 보면, Member class에 id와 username 밖에 없음. 연관관계 주인이 Team의 members가 되는 것.
- 하지만 **DB 테이블 구조 상 다 쪽이 FK 컬럼을 갖게** 되므로, 일 쪽의 필드가 연관관계 주인이 되면 **일 쪽에서 persist 한게 다 쪽의 테이블로 쿼리가 날아가게 됨**.
    - 테이블 구조 상 MEMBER가 다수이므로 FK 컬럼이 MEMBER 테이블에 추가되어야 함.
    - 하지만 JPA 상에서 연관관계 주인을 Team 쪽으로 잡아놨으므로, Team 객체를 생성한 후 persist 하면 MEMBER 테이블의 FK 값을 추가하도록 쿼리가 나갈 수 밖에 없음.

<Member class>

```java
@Entity
public class Member{
	@Id @GeneratedValue
	@Column(name = "MEMBER_ID")
	private Long id;

	@Column(name = "USERNAME")
	private String username;

	...
}
```

<Team class>

```java
@Entity
public class Team{
	@Id @GeneratedValue
	@Column(name = "TEAM_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@OneToMany
	@JoinColumn(name = "TEAM_ID")
	private List<Member> members = new ArrayList<>();

	...
}
```

- 일 쪽에서 연관관계 주인을 갖게 되므로, @OneToMany 붙이고 @JoinColumn도 붙인다.
    - 여기서 유의깊게 봐야할 점은 당연히 JoinColumn의 name 속성에는 똑같이 TEAM_ID가 들어간다.
    - 구현 방식만 다대일에서 일대다로 바뀌었을 뿐, 또한 이렇게 바뀐 것은 JPA 상에서 구현하는 방식이 달라진거지 DB 구조가 달라지는게 아님. DB 구조는 어차피 다 쪽이 FK 컬럼을 가져야 하므로 달라지지 않음.
    - 앞서 다루었듯, join 쿼리 날릴 때 기준이 되는 컬럼명을 넣어야 하므로, FK를 넣어야 함. 따라서 TEAM_ID가 들어감
- Main에서는 다음과 같이 활용될 수 있다.

```java
Member member = new Member();
member.setUsername("member1");
em.persist(member);

Team team = new Team();
team.setName("team1");
team.getMembers().add(member);
em.persist(team);
```

- 이렇게 구현하고 테이블이 생성되는 쿼리(DDL)를 보면, FK 없이 MEMBER와 TEAM 테이블을 생성했다가, MEMBER 테이블에 FK 제약조건을 추가하게 된다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%203.png)

- 이렇게 구현해도 DB에 저장되는건 다대일로 구현했을 때랑 똑같이 MEMBER 테이블에 FK 컬럼인 TEAM_ID가 추가된 모습으로 된다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%204.png)

- 하지만 DB로 가는 쿼리를 확인해 보면 마지막에 MEMBER 테이블로 update 쿼리가 나가는 것을 볼 수 있다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%205.png)

- JPA 상에서는 team 객체의 members 필드에 member 객체를 추가한거지만, 이를 DB에 반영하려면 MEMBER 테이블 내용을 고쳐야 하는 것이므로 update 쿼리가 나갈 수 밖에 없다.

<정리>

- 일대다 단방향은 일(1) 쪽에서 연관관계 주인을 갖게 된다.
- 하지만 테이블에서 일대다 관계는 항상 다(N) 쪽에 외래 키(FK)가 있다.
- 즉, 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하게 되는 특이한 구조가 만들어진다.
- 꼭 @JoinColumn 어노테이션을 활용해야 한다. 안그러면 자동으로 join 테이블 방식을 활용하게 된다. (중간에 테이블이 하나 추가된다.)
    - 자동으로 ‘TEAM_MEMBER’ 테이블이 생겨버리게 됨.
        
        ![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%206.png)
        
    - @JoinTable 어노테이션으로 이렇게 중간에 join 테이블 만들어지도록 설정할 수도 있지만, 굳이 그럴 필요가 없음. 그리고 의도치 않게 테이블이 하나 더 들어가는 것이니, 성능도 저하될 수 있음.
- 따라서 일대다 단방향의 단점은 다음과 같다.
    - **엔티티가 관리하는 외래키가 다른 테이블에 있게 된다. 이거 자체가 어마어마한 단점임.**
        - 객체 상에서는 FK를 관리하는 필드가 Team class에 있는데, 정작 테이블에서는 FK가 MEMBER 테이블에 위치하게 됨.
    - 연관관계 관리를 위해 추가로 UPDATE 쿼리가 실행된다.

⇒ ⭐아무리 다대일 단방향 매핑이 안맞는 상황이라도, 일대다 단방향 매핑보다는 **다대일 양방향 매핑**을 사용하자.⭐

### 일대다 양방향

- 사실 JPA에서 일대다 양방향 매핑은 공식적으로 존재하지 않는다.
- 하지만 개념적으로 일대다 양방향 기능을 수행하도록 설정할 수는 있다. (야매로..)
- 단방향 매핑처럼 다(N) 쪽이 연관관계 주인인 것처럼 걸어놓고, 등록insert, 수정update을 제한시키면 됨.

```java
@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
private Team team;
```

- 뭔가 말도 안되는 방식처럼 보이지만, 일대다 양방향 말고 한번씩 이런 기능이 필요할 때가 있음.
    - 매핑은 해놓고 DB에 반영은 안해야 할 때 위와 같이 설정해두면 된다.
- ⭐ **일대다 단방향 양방향 쓰지 말고** **그냥 다대일 양방향을 쓰자.** ⭐
    - 실제로 운영될 때는 테이블 수십개가 엮여서 돌아가는데, 쿼리가 다른 테이블로 날아가고 그러면 관리하기 너무 빡세짐.
    - 최대한 단순하게 설계하고 개발해서 운영, 유지보수 측면에서 메리트를 가져가는게 훨씬 좋음.

### 일대일 관계

- 일대일 관계는 그 반대도 일대일이다.
- 주 테이블이나 대상 테이블 중에 아무 곳이나 선택해서 외래키(FK)를 설정하면 됨.
    - 주 테이블에 외래키를 추가하거나
    - 대상 테이블에 외래키를 추가한다.
- 일대일은 일대다, 다대일과 유사하지만, 차이점은 **외래키(FK)에도 유니크(UNI) 제약조건을 추가**한다는 것.

**<예제 설정>**

- MEMBER 테이블과 일대일 연관관계를 맺는 LOCKER 테이블 설정
- 하나의 Member는 하나의 Locker를 쓸 수 있음.
- 따라서 MEMBER와 LOCKER 테이블 둘 중 어느 곳이든 FK를 설정할 수 있음.
    - Member가 Locker 번호를 갖고 있거나
    - Locker에 Member 번호가 붙여지거나

**<일대일, 주 테이블에 외래 키 추가, 단방향>**

- MEMBER를 주 테이블로 설정한 것.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%207.png)

- 어노테이션만 달라지고 사실 다대일 단방향 매핑과 매우 유사하다.
- 먼저 Locker 엔티티 생성

```java
@Entity
public class Locker{
	@Id @GeneratedValue
	@Column(name = "LOCKER_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;
}
```

- 여기서는 주 테이블에 FK를 생성할 것이므로, Member 엔티티에 Locker 추가

```java
...
@OneToOne
@JoinColumn(name = "LOCKER_ID")
private Locker locker;
...
```

- 다대일과 매우 유사함. 하지만 일대일 관계이므로 @OneToOne 어노테이션이 활용됨.
- @JoinColumn 어노테이션 꼭 써주는게 좋음.

**<일대일, 주 테이블에 외래 키 추가, 양방향>**

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%208.png)

- 다대일에서 양방향 한 것과 거의 유사함.
- 양방향이므로 Locker에도 Member 객체 필드를 추가해준다.

```java
@Entity
public class Locker{
	@Id @GeneratedValue
	@Column(name = "LOCKER_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@OneToOne(mappedBy = "locker")
	private Member member;
}
```

- 여기서도 동일하게 일대일 관계이므로 @OneToOne 어노테이션이 활용됨
- 여기서는 연관관계 주인이 아니므로 mappedBy 속성으로 연관관계 주인을 가리켜야 한다.

**<일대일, 대상 테이블에 외래키 두기, 단방향>**

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%209.png)

- 위 사진과 같이 JPA 상에서는 주 엔티티(Member)에 두고, 실제 DB 상에서 FK는 대상 테이블(LOCKER)에 둘 수는 없다.
    - 즉, FK는 LOCKER 테이블에 만들고, 이 FK를 JPA에서 관리하는건 Member에서 하고 싶을 경우
    
    → 안된다.
    
- 기술 지원도 안되고 방법도 없음.
- 근데 굳이 이렇게 꼬아서 할 필요 없이, 주 테이블에 외래키 둔 단방향을 그냥 뒤집으면 됨.
- 그냥 LOCKER 테이블에 FK 두고 관리도 Locker 엔티티에서 하면 된다.

**<일대일, 대상 테이블에 외래키 두기, 양방향>**

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2010.png)

- 이 경우는 그냥 **<일대일, 주 테이블에 외래 키 추가, 양방향> 경우를 반대로 뒤집은 것.**
- Locker에 연관관계 주인을 두고, LOCKER 테이블에 FK 만들면 됨.

<Locker>

```java
@Entity
private class Locker{
	@Id @GeneratedValue
	@Column(name = "LOCKER_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@OneToOne
	@JoinColumn(name = "MEMBER_ID")
	private Member member;
}
```

<Member>

```java
...
	@OneToOne(mappedBy = "member")
	private Locker locker;
...
```

**<그렇다면 어느 곳에 FK를 두는게 더 좋을지?>**

- 위 예시들을 보면, 일대일 관계는 사실 **어느 곳에 FK를 두어도 기능은 할 수 있다.**
    - MEMBER에 FK로 LOCKER_ID 를 두거나
    - LOCKER에 FK로 MEMBER_ID 를 두거나
- 여기서부터는 **상황에 따라** 결정해야함.
    - 지금은 일대일이지만, 나중에 한쪽이 다수가 될 가능성이 있을 경우, **다수가 될 가능성이 높은 쪽에 FK를 두는게 더 이득**이다.
        - 만약 나중에 한명의 회원이 여러 라커를 가질 수 있도록 로직이 변경될 경우
            - 처음부터 LOCKER에 FK가 있게되면, 그냥 해당 FK에 **유니크 제약조건만 없애면 됨**
            - 하지만 MEMBER에 FK가 있으면, 해당 **FK 지우고 LOCKER에 FK 추가해야됨**
        - 또 반대로 하나의 라커를 여러 회원이 쓸수 있도록 로직이 변경될 경우도 똑같다.
    - 하지만 그런 기획이 보이지 않으면, **JPA 개발 과정에서 여러번 쓰이는 쪽에 FK를 두는게 좋을 수 있다.**
        - 예제에서는 Locker 보다는 Member가 많이 쓰일 것이다.
        - 만약 Member들 중, Locker를 쓰고 있을 경우와 안쓰고 있을 경우를 나누어 뭔가 작업을 해야할 경우
            - Member에 FK가 있으면, **처음에 Member 데이터 find() 할 때 어차피 Locker 데이터도 딸려오게됨.**
                
                → **그냥 바로 member.getLocker().~~ 이렇게 쓰면 됨**
                
            - 하지만 Locker에 FK가 있으면, 양방향 걸고, Locker 찾고 Member 찾고.. **쿼리 여러번 날려야됨**
        - 따라서 이런 특수한 경우에 대해서도 고려해 볼 필요가 있다.

**<일대일 정리>**

- 주 테이블 : 주로 액세스 되는 테이블
- 대상 테이블 : 주 테이블과 일대일 연관관계를 맺는 대상 테이블
- 주 테이블에 외래키
    - 주 객체가 대상 객체의 참조를 갖는 것과 같이, 주 테이블에 외래키를 두고 대상 테이블을 찾는다.
    - 객체지향 개발자들이 많이 선호하는 방식이다.
    - JPA 매핑 과정도 편리하다.
    - **장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인할 수 있다.**
    - **단점 : 값이 없으면 외래 키에 null을 허용해야 한다.**
        - null은 최대한 줄이는게 더 좋다.
- 대상 테이블에 외래키
    - 대상 테이블에 외래키가 있는 것.
    - 전통적인 데이터베이스 개발자들이 선호하는 방식이다.
    - **장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지할 수 있다.**
    - **단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩된다. 비교적 치명적이다. (프록시는 추후에 다룸)**
- JPA 개발자 입장에서는 주 테이블에 외래키를 두는걸 더 선호할 수 밖에 없음. 하지만 해당 방식은 DBA 들이 싫어할 수 있으므로 충분한 협의가 필요하다.

### 다대다 관계

- 웬만하면 쓰지 않는게 좋다. 쓰면 안좋음..
- 다대다에서 자동으로 생성된 테이블로 해결될 수 없음.
- ⭐ **실무에서는 안씀.** ⭐

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2011.png)

- 원래 RDB는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
- 연결 테이블을 추가해서 일대다 - 다대일 관계로 풀어내야 한다.
- 즉, JPA 에서 개발할 때는 다대다가 가능함. 그냥 서로를 참조할 수 있는 컬렉션을 갖고 있으면 된다.
    - 위 사진에서 Member는 Product 컬렉션을 갖고 있고,
    - Product는 Member 컬렉션을 갖고 있는 것.
- 객체에서 구현이 가능하지만 관계형 데이터베이스에서는 불가능하기 때문에 중간에 Join 할 수 있는 테이블을 추가하는 방식으로 구현되게 됨.
    - 중간에 Join 할 수 있는 MEMBER_PRODUCT 테이블이 생성되고, MEMBER와 PRODUCT를 가리키는 FK가 설정됨

**<다대다 단방향 구현>**

- @ManyToMany 어노테이션을 활용한다.
- @JoinTable로 연결 테이블을 지정한다.
- 단•양방향 모두 가능하다.
- Member 에서 다대다 구현하면 아래와 같이 구현될 수 있다.

```java
...
@ManyToMany
@JoinTable(name = "MEMBER_PRODUCT")
private List<Product> products = new ArrayList<>();
...
```

- @ManyToMany 어노테이션이 쓰임.
- @JoinTable 어노테이션으로 중간에 연결 테이블을 설정할 수 있음. name 속성으로 MEMBER_PRODUCT 라는 이름의 join 테이블을 만들 수 있는 것.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2012.png)

- 이렇게 MEMBER_PRODUCT 테이블이 생성되고, 안에 MEMBER와 PRODUCT를 가리키는 필드가 설정됨.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2013.png)

- 그리고 FK 제약조건도 자동으로 생성된다.

**<다대다 양방향 구현>**

- Product 엔티티에도 추가해주면 됨.

```java
@Entity
public class Product{
	@Id @GeneratedValue
	@Column(name = "PRODUCT_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@ManyToMany(mappedBy = "products")
	private List<Member> members = new ArrayList<>();
}
```

- 똑같이 mappedBy로 연관관계 주인을 가리킨다.

**<다대다 쓰면 안되는 이유>**

- 편리해 보이지만, 실무에서는 쓰면 안된다.
- 연결 테이블이 단순히 연결만 하고 끝나지 않는다.
    - 보통 이렇게 연결시키는 용도로만 쓰이는 테이블은 없다.
    - 무조건 중간에 주문 시간, 수량 등 추가되는 데이터가 있음.
    - 하지만 다대다를 쓸 경우, 이런 중간 테이블을 JPA에서 관리하지 않게 됨.
- 다대다 쓰면 그냥 중간 테이블만 알아서 만들어주고, 이 테이블을 관리할 수가 없게됨.
- 그리고 중간 테이블이 알아서 생기는 거기 때문에, 개발하다보면 내 생각과 다른 이상한 쿼리가 나간다.

**<다대다 극복 방법>**

- 연결 테이블을 JPA에서 하나의 엔티티로 만드는 것.
- 즉, @ManyToMany → @OneToMany - @ManyToOne 관계를 양쪽으로 두개 만듦

<MemberProduct 엔티티 생성>

```java
@Entity
public class MemberProduct{
	@Id @GeneratedValue
	@Column(name = "MEMBER_PRODUCT_ID")
	private Long id;

	@ManyToOne
	@JoinColumn(name = "MEMBER_ID")
	private Member member;

	@ManyToOne
	@JoinColumn(name = "PRODUCT_ID")
	private Product product;
}
```

- 중간 연결 엔티티도 하나의 테이블이기 때문에 본인만의 PK 값을 설정해 준다.
- Member와 Product 모두 FK로 가리키도록 @ManyToOne 어노테이션과 @JoinColumn 어노테이션을 활용해줌.
- @JoinColumn은 각각 join 되는데 MEMBER_ID와 PRODUCT_ID 가 쓰이므로, 해당 컬럼 명을 적어준다.

<Member 엔티티 설정 - 양방향>

```java
...
@OneToMany(mappedBy = "member")
private List<MemberProduct> memberProducts = new ArrayList<>();
...
```

<Product 엔티티 설정 - 양방향>

```java
...
@OneToMany(mappedBy = "product")
private List<MemberProduct> memberProducts = new ArrayList<>();
...
```

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2014.png)

- 이렇게 설정하면 위 사진과 같이 중간 테이블에서도 다른 컬럼들을 추가해 활용할 수 있다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2015.png)

- 보통 위 사진과 같이 연결 테이블에서 양쪽에 물리는 FK(MEMBER_ID, PRODUCT_ID)를 PK로 설정하여 활용하는 경우도 많음.
- 이 방법도 많이 쓰이고 좋지만, 어쨌든 해당 컬럼들이 MEMBER와 PRODUCT에 물리게 됨. 그럼 운영 과정에서 제약되는게 있을 수 있음.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2016.png)

- 따라서 위와 같이 다른 테이블과 전혀 상관없이 본인만의 PK를 따로 두고 @GeneratedValue로 계속 올라가면서 설정되도록 두고, FK는 따로 해두는게 더 융통성이 생김. 더 유연하게 된다.
- ⭐ **PK는 웬만하면 아무 의미 없는 본인만의 값을 갖는게 제일 좋다.** ⭐

### 실전 예제

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2017.png)

- 엔티티 및 테이블 추가 : 배송, 카테고리
- 주문 : 배송 = 1 : 1
- 상품 : 카테고리 = N : M

**<ERD>**

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2018.png)

**<Entity 구조도>**

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20771c43127d9044f7baccaee8c3589c5b/Untitled%2019.png)

- 원래는 다대다 쓰면 안되지만 본 예제에서는 설명을 위해 활용함.

**<구현>**

<Order 엔티티에 delivery 관계 추가>

```java
...
@OneToOne
@JoinColumn(name = "DELIVERY_ID")
private Delivery delivery;
...
```

<Delivery>

```java
@Entity
public class Delivery{
	@Id @GeneratedValue
	@Column(name = "DELIVERY_ID")
	private Long id;

	@Column(name = "CITY")
    private String city;

  @Column(name = "STREET")
  private String street;

  @Column(name = "ZIPCODE")
  private String zipcode;

	@Enumerated(EnumType.STRING)
	private DeliveryStatus status;

	@OneToOne(mappedBy = "delivery")
	private Order order;
```

- DeliveryStatus

```java
public enum DeliveryStatus{
	Preparing, Delivering, Completed
}
```

<Category, Item - 다대다>

- Category

```java
public class Category{
	@Id @GeneratedValue
	@Column(name = "CATEGORY_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@ManyToOne
	@JoinColumn(name = "PARENT_ID")
	private Category parent;

	@OneToMany(mappedBy = "parent")
	private List<Category> child = new ArrayList<>();

	@ManyToMany
	@JoinTable(name = "CATEGORY_ITEM", 
						joinColumns = @JoinColumn(name = "CATEGORY_ID")
						,inverseJoinColumns = @JoinColumn(name = "ITEM_ID"))
	private List<Item> items = new ArrayList<>();
}
```

- parent, child
    - 같은 Category 엔티티이면서 부모 자식 간 상속이 가능함.
    - 보통 부모 : 자식 = 1 : N 임.
    - 위 코드에서 자식이 N 이므로, @ManyToOne 으로 매핑함. : parent
        - 자식이 parent를 갖고 있으므로 변수 명 parent
        - 자식이 다수 쪽이므로 연관관계 주인을 parent로 설정
    - 반대로 부모는 @OneToMany 로 매핑하고, mappedBy로 parent를 가리킴
        - 부모가 child를 갖고 있으므로 변수 명 child
        - 다수의 자식을 가지므로 리스트로 설정
    - 이렇게 되면 트리처럼 쭉 펼쳐져 나갈 수 있음. 아마 후에 다룰 것으로 예상.
- 다대다 매핑 : @ManyToMany, @JoinTable
    - @ManyToMany : 다대다 매핑
    - @JoinTable : 현재 Category 엔티티가 연관관계 주인을 맡음.
        - name : 연결 테이블의 이름 설정
        - joinColumn : 연관관계 주인을 갖는 테이블의 join 컬럼명. : CATEGORY_ID
            
            → 연결 테이블에서 CATEGORY 테이블과 join할 때 쓰일 컬럼의 이름을 설정하는 것.
            
        - inverseJoinColumn : 상대방 테이블과 join할 때 쓰일 컬럼 명 : ITEM_ID
            
            → 반대로 연결 테이블에서 ITEM 테이블과 join할 때 쓰일 컬럼의 이름을 설정.
            

- Item

```java
...
@ManyToMany(mappedBy = "items")
private List<Category> categories = new ArrayList<>();
...
```

- 다대다도 똑같이 연관관계 주인이 있고, 이를 mappedBy로 가리켜야 한다.

<Category, Item - 일대다, 다대일로 나누기>

- 연결 테이블 관리할 엔티티 생성 : CategoryItem (이름 그럴듯하게 바꿔서 써도 됨)

```java
public class CategoryItem{
	@Id @GeneratedValue
	@Column(name = "CATEGORY_ITEM_ID")
	private Long id;

	@ManyToOne
	@JoinColumn(name = "CATEGORY_ID")
	private Category category;

	@ManyToOne
	@JoinColumn(name = "ITEM_ID")
	private Item item;
}
```

- Category

```java
public class Category{
	@Id @GeneratedValue
	@Column(name = "CATEGORY_ID")
	private Long id;

	@Column(name = "NAME")
	private String name;

	@ManyToOne
	@JoinColumn(name = "PARENT_ID")
	private Category parent;

	@OneToMany(mappedBy = "parent")
	private List<Category> child = new ArrayList<>();

	@OneToMany(mappedBy = "category")
	private List<CategoryItem> categoryItemList = new ArrayList<>();
}
```

- Item

```java
...
@OneToMany(mappedBy = "item")
private List<CategoryItem> categoryItemList = new ArrayList<>();
...
```