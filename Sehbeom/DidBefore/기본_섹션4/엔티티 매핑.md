# 엔티티 매핑

블로그 작성

1. 데이터베이스 스키마 자동 생성 내용
2. 어노테이션 정리 (Entity, Table, Column 등)
3. 기본 키 맵핑

객체와 DB 사이의 매핑 과정

- 객체와 테이블 매핑 : @Entity, @Table
- 필드와 컬럼 매핑 : @Column
- 기본 키 매핑(PK) : @Id
- 연관관계 매핑 : @ManyToOne, @JoinColumn (DB에서 1:N과 같은 연관관계를 JPA에서 어떻게 나타내는지?)

### @Entity

- @Entity가 붙은 클래스는 JPA가 관리하는 엔티티임.
- JPA를 사용해서 테이블과 매핑할 클래스는 무조건 붙여줘야함.
- 유의사항
    - 기본 생성자는 필수이다. : 파라미터가 없는 public 혹은 protected 생성자
    - final 클래스, enum, interface, inner 클래스는 사용할 수 없다. (@Entity를 붙일 수 없다.)
    - 저장할 필드에 final은 사용하면 안된다.
- 속성
    - name 속성
        - JPA에서 사용할 엔티티의 이름을 지정함.
        
        ```java
        @Entity(name = "Member")
        ```
        
        - 아무것도 지정해주지 않으면 클래스 이름이 그대로 사용된다.
        
        ```java
        //위 예시와 동일하게 name 속성이 설정된다.
        @Entity
        public class Member{
        ~~
        ```
        
        - 같은 이름의 다른 클래스가 없으면 가급적 기본값을 그대로 사용해주면 된다.

### @Table

- 엔티티와 매핑할 테이블을 지정한다. (DB의 테이블)

```java
// 이렇게 지정하면 DB의 테이블 중 'MBR' 이라는 이름의 테이블과 매핑된다.
@Entity
@Table(name = "MBR")
public class Member{
~~
```

- @Table 을 설정하지 않으면 그냥 클래스 이름과 동일한 테이블과 연결된다.
- 속성
    - name : 매핑할 테이블 이름. Default : 엔티티 이름을 사용함.
    - catalog : 데이터베이스 catalog 매핑
    - schema : 데이터베이스 schema 매핑
    - uniqueConstraints(DDL) : DDL 생성 시에 유니크 제약 조건을 생성함.

### 데이터베이스 스키마 자동 생성

- 해당 기능을 사용하면 애플리케이션 로딩 시점에 DB 테이블을 자동으로 생성해줌.
- 애플리케이션 운영 도중에는 쓰면 안됨. 개발 단계이거나 로컬에서 혼자 개발할 때 쓰면 유용함.
- DDL을 애플리케이션 실행 시점에 자동으로 생성해주는 기능이다.
    - DDL? DML, DCL
        
        < DDL (Data Definition Language) >
        
        - 데이터베이스를 정의하는 언어
        - 데이터의 전체 골격을 결정하는 역할의 언어
            - CREATE : 데이터베이스, 테이블 등을 생성
            - ALTER : 테이블 수정
            - DROP : 데이터베이스, 테이블 삭제
            - TRUNCATE : 테이블 초기화
        
        < DML (Data Manipulation Language) >
        
        - 데이터 조작어
        - 데이터베이스의 데이터에 대한 CRUD를 수행하는 언어
            - SELECT
            - INSERT
            - UPDATE
            - DELETE
        
        < DCL (Data Control Language) >
        
        - 데이터베이스에 접근하거나 객체에 권한을 주는 등의 역할을 하는 언어.
        - 데이터를 제어하는 언어.
        - 데이터 보안, 무결성, 회복 등을 정의.
            - GRANT : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 부여
            - REVOKE : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 박탈, 회수
            - COMMIT : 트랜잭션 작업이 정상적으로 완료
            - ROLLBACK : 트랜잭션의 작업이 비정상적으로 종료되었을 때 원래 상태로 복구.
- 보통 백엔드 개발할 때 DB에 테이블들 다 구성해놓고 서버 개발을 시작하지만, 해당 기능을 활용하면 그럴필요 없이 Class 다 정의하고 매핑 과정 해두면 애플리케이션 로딩 시점에 알아서 DDL 생성해서 DB와 테이블을 생성해줌.
    - 테이블 중심 → 객체 중심 개발
- 데이터베이스 방언(MySQL? Oracle? H2? 등등..)을 활용해서 데이터베이스에 맞는 적절한 DDL이 생성될 수 있다.
- 이렇게 생성된 DDL 내용을 확인할 수 있으며, 이는 꼭 개발 장비에서만 사용해야 한다.
    - 운영 서버에서는 사용하지 말 것.
    - 만약 사용하려면 적절히 다듬은 후 사용해야 한다.

<적용 방법>

- [hibernate.hbm2ddl.auto](http://hibernate.hbm2ddl.auto) 를 사용해야 한다.
- 프로젝트/src/main/resources/META-INF/persistence.xml 에 아래 <property> 추가

```java
<property name="hibernate.hbm2ddl.auto" value="create" />
```

- value 속성 내용은 아래와 같다.
    - create : 기존 테이블 삭제 후 다시 생성 (DROP → CREATE)
    - create-drop : create와 같지만, 종료 시점에 테이블을 DROP 함 (DROP → CREATE → DROP)
    - update : 변경분만 반영한다.(운영 DB에서는 사용하면 안된다.)
        - 객체 내에서 특정 Column을 추가하는 경우, drop → create가 아닌, alter로 해당 내용을 반영한다.
        
        →테이블 내용 안바뀌고 Column 추가만 된다. 테이블 내용 유지하면서 변경 내용을 반영하고 싶을 때 활용!
        
        - 특정 Column을 빼는 경우는 반영 안됨! ( Column 잘못 지우면 데이터가 통째로 날아가기 때문에!)
    - validate : 엔티티와 테이블이 정상적으로 매핑 되었는지 여부만 확인한다.
        - DB 테이블 내용과 JPA의 Class 매핑 내용이 일치하지 않을 경우, 에러를 발생시킨다.
    - none : 사용하지 않음
        - 주석처리와 똑같음.
        - 사실 none 이라는 속성은 없지만 (그냥 아무렇게나 써도 none 기능 똑같이 한다. 없는 속성이니까) 관례상 none이라고 적는다.
- 추가하고 실행하면 아래와 같이 DDL이 생성되는 것을 확인할 수 있다. (value = “create” 이므로 DROP → CREATE)

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled.png)

- 이는 아래 코드와 같이 Member 클래스에서 @Entity 로 매핑해 두었기 떄문에 JPA 관리 하에 있게 되고, 이에 따라 자동으로 테이블을 지우고 생성해 줄 수 있는 것.

```java
@Entity
public class Member{
~~
```

<DDL 생성 기능>

- 제약 조건 추가 : @Column 을 활용하여 제약조건을 걸어줄 수  있다.
    - ex) 유니크, 회원 이름은 필수, 10자 초과X
    
    ```java
    @Column(unique = true, nullable = false, length = 10)
    ```
    
    - 이렇게 걸어두고 실행하면 제약조건을 포함한 DDL이 생성된다.
- 또는 아래와 같이 유니크 제약조건을 생성해주는 것도 가능하다.
    - 테이블 단위에서 유니크 제약조건 생성
    
    ```java
    @Entity
    @Table(uniqueConstraints = {@UniqueConstraints( name = "NAME_AGE_UNIQUE", columnNames = {"NAME", "AGE"})})
    public class Member {
    ...
    ```
    
    ![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%201.png)
    
    - 위 사진의 마지막 alter문을 통해 제약조건을 설정하는 DDL이 생성되는 것을 확인할 수 있다.
- 이런 제약조건들은 DB 로직에 영향을 줄 뿐, JPA 실행 로직에는 아무런 영향을 주지 않는다. 그냥 DDL 생성 과정만 도와줄 뿐이다.

- 원래 개발할 때 만약 테이블 내용이 달라지거나 서버 코드 내용이 달라질 경우, 이를 DB에 반영하려면 DB에 가서 테이블 새로 만들거나 ALTER로 수정하는 과정을 거쳐야 한다. 또 수정한 내용이랑 서버랑 일일이 다 맞추고 그러다보면 매우 귀찮음.
- 사실 혼자 개발할 때 이런 과정들이 매우 번거롭기 때문에, 해당 기능을 활용해서 JPA 개발 내용만 수정해도 수정한 내용에 맞게 알아서 테이블이 지워지고 생성되는 것은 매우 큰 메리트!

### 데이터베이스 스키마 자동 생성 주의점

- **절대 운영 장비에서는 create, create-drop, update 속성을 사용하면 안된다.**
- 개발 초기 단계에서는 create 혹은 update 로 해두고 쓰면 된다.
- 테스트 서버(팀단위 개발에서 공동으로 개발 중인 서버)에서는 update 혹은 validate 으로 해두고 쓰는게 좋다.
    - drop 과정이 없도록 하는게 좋다.
    - 다른 팀원이 등록해 둔 데이터들이 다 날아갈 수 있으므로.
- 스테이징과 운영 서버는 validate 혹은 none 으로 해둬야 한다.
- **그냥 혼자 로컬에서 개발할 때만 쓰는게 제일 속편하다.**

### 필드와 컬럼 매핑

<요구사항>

- 회원은 일반 회원과 관리자로 구분되어야 한다. : 값 정하기?
- 회원 가입일과 수정일이 있어야 한다. : created_at, updated_at ?
- 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다. : content 필드?

<구현>

- 먼저 코드부터 본다.

```java
package hellojpa;

import javax.persistence.*;
import java.util.Date;

@Entity
@Table(uniqueConstraints = {@UniqueConstraint( name = "NAME_AGE_UNIQUE", columnNames = {"NAME", "AGE"})})
public class Member {

    @Id
    private Long id;

    @Column(name = "name")
    private String username;

    private Integer age;

    @Enumerated(EnumType.STRING)
    private RoleType roleType;

    @Temporal(TemporalType.TIMESTAMP)
    private Date createDate;

    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;

    @Lob
    private String description;

    public Member(){

    }
}
```

<@Id>

```java
@Id
private Long id;
```

- PK 매핑

<@Column>

```java
@Column(name = "name")
private String username;
```

- 객체는 username이라고 쓰고 싶은데 DB의 Column 이름은 name으로 되어야 할 때, name 속성을 설정해주면 된다.

```java
private Integer age;
```

- Integer라고 해두면 DB에 알아서 int 형태로 반영된다.

<@Enumerated>

```java
@Enumerated(EnumType.STRING)
private RoleType roleType;
```

- java의 enum 타입을 쓰고 싶을 경우, @Enumerated를 쓰면 된다.
- 위 코드를 보면 RoleType 이라는 타입으로 되어 있는데, RoleType은 필요에 맞추어 생성해주면 된다.

(본 실습에서는 Member class와 동일한 위치에 RoleType Enum을 생성했다.)

```java
package hellojpa;

public enum RoleType{
	USER, ADMIN
}
```

- 이렇게 해두면 USER 혹은 ADMIN 중 선택이 가능할 것으로 예상된다.

<@Temporal>

```java
@Temporal(TemporalType.TIMESTAMP)
private Date createDate;

@Temporal(TemporalType.TIMESTAMP)
private Date lastModifiedDate;
```

- 생성일자 혹은 수정일자를 저장할 때, @Temporal을 붙여주면 된다.
- TemporalType 에는 3가지가 있다. 이는 DB에서 주로 다음 3가지에 맞춰서 저장되므로 이에 맞춘 것.
    - DATE
    - TIME
    - TIMESTAMP

<@Lob>

```java
@Lob
private String description;
```

- DB에 VARCHAR를 넘어서는 큰 컨텐츠를 넣고싶은 경우, @Lob 을 쓰면 된다.
- @Lob 는 DB의 타입 ‘CLOB’, ‘BLOB’ 과 연결된다.
    - CLOB, BLOB
        - 사이즈가 큰 데이터를 외부 파일로 저장하기 위한 데이터 타입.
        - 데이터 자체를 저장하는게 아닌, DB에 저장된 LOB 값의 위치 포인터를 저장하므로, SELECT문을 사용하면 위치 값만 얻을 수 있다.
        - CLOB : 문자열 데이터
        - BLOB : 바이너리 데이터
- 여기서는 String이므로 CLOB으로 생성된다.

- 위 코드를 실행해보면, 아래와 같이 DDL이 생성되는 것을 확인할 수 있다.

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%202.png)

<매핑 어노테이션 정리>

- @Column : 컬럼 매핑
- @Temporal : 날짜 타입 매핑
- @Enumerated : enum 타입 매핑
- @Lob : BLOB, CLOB 매핑
- @Transient : 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)
    - DB에 반영하지 않고 객체 내에서만 임시로 지정해두거나, 메모리에서만 필요한 경우, @Transient 어노테이션을 붙여주면 DB와 매핑되지 않는다.

<@Column의 속성>

- 사실상 가장 많이 쓰이고 가장 중요함.
- name : 필드와 매핑할 테이블의 **컬럼 이름**. Default : 객체의 필드 이름 그대로
- insertable, updatable : 등록, 변경 가능 여부. Default : TRUE
    - 해당 Column을 의 내용을 DB에 반영할건지 여부를 결정. false로 해두면 DB에 저장되지 않음.
- nullable(DDL) : null 값 허용 여부. false로 설정 → DDL 생성 시 not null이 붙음
- unique(DDL) : @Table의 uniqueConstraints와 같음. 하지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 활용
    - 하지만 해당 속성은 잘 안쓰인다. 해당 속성으로 유니크 제약조건을 걸면 제약조건 이름이 랜덤으로 결정돼서 이상한 문자들로 이름이 결정됨. 이는 실제 운영하는데 적용될 수 없다.
    - 따라서 위에서 했던 것 처럼 @Table의 uniqueConstraints로 이름을 정해서 제약조건을 걸어주어야 한다.
- columnDefinition(DDL) : DB 컬럼 정보를 직접 정의할 수 있음. Default :
    - ex) varchar(100) default ‘EMPTY’
    
    ```java
    @Column(columnDefinition = "varchar(100) default ‘EMPTY’")
    ```
    
- length(DDL) : 문자 길이 제약조건. String 타입에만 사용함. Default : 255
- precision, scale(DDL) : BigDecimal, BigInteger 타입에서 사용. double, float 타입에는 적용되지 않음. 아주 큰 숫자나 정밀한 소수를 다루어야 할 때 활용.
    - precision : 소수점을 포함한 전체 **자릿수.** Default : 19
    - scale : **소수의 자릿수**. Default : 2

<@Enumerated 속성 유의사항>

- 자바의 enum 타입을 매핑할 때 사용된다.
- value 속성
    - EnumType.ORDINAL : enum 인덱스를 DB에 저장한다. Default.
    - EnumType.STRING : enum 이름을 DB에 저장한다.
- 여기서 EnumType.ORDINAL 이 Default로 설정되어 있지만, 웬만하면 EnumType.STRING 을 써야한다.
- 위 코드의 enum타입 ‘RoleType’ 을 예시로 보면,
    - EnumType.ORDINAL일 경우 → DB의 roleType Column이 integer 타입으로 생성됨.
        - USER : 0 으로 DB에 저장
        - ADMIN : 1 로 DB에 저장
    - EnumType.STRING일 경우 → DB의 roleType Column이 varchar 타입으로 생성됨.
        - USER 글자 그대로 저장
        - ADMIN 글자 그대로 저장
- 여기서 만약 RoleType에 ‘GUEST’ 라는 role이 앞 순서로 추가될 경우,
    - EnumType.ORDINAL일 경우
        - GUEST : 0, USER : 1, ADMIN : 2 가 됨.
        - 하지만 기존에 저장되어 있던 데이터는 수정되지 않음.
        - GUEST 추가된 후에 데이터 저장하면 0 으로 저장됨.
        
        ⇒ 0이 GUEST인지 USER인지 대혼란이 발생한다.
        
    - EnumType.STRING일 경우
        - 글자 그대로 저장되므로 대혼란 발생할 일이 없다.
- 따라서 @Enumerated 어노테이션을 쓸 때는 무조건 **EnumType.STRING** 으로 지정해주어야 한다.

```java
@Enumerated(EnumType.STRING)
private RoleType roleType;
```

<@Temporal>

- 사실 @Temporal 어노테이션은 예전에 쓰이던 것이다.
- 최근 Hibernate에서 따로 어노테이션을 붙이지 않아도 자동으로 DB에 타입을 반영해주는 기능이 생겼다.

→ LocalDate, LocalDateTime 이 친구들을 쓸 때는 @Temporal 어노테이션을 생략할 수 있다.

- LocalDate : 년월일 / DB의 date 타입과 매핑됨
- LocalDateTime : 년월일 시분초 / DB의 timestamp 타입과 매핑됨.

```java
private LocalDate testLocalDate;
private LocalDateTime testLocalDateTime;
```

- 만약 Temporal을 쓰게 될 때는 속성을 지정해주어야 한다.
    - [TemporalType.DATE](http://TemporalType.DATE) : 년월일 / DB의 date 타입과 매핑됨. (ex. 2013-10-11)
    - TemporalType.TIME : 시분초 / DB의 time 타입과 매핑됨. (ex. 11:11:11)
    - TemporalType.TIMESTAMP : 년월일 시분초 / DB의 timestamp 타입과 매핑됨. (ex. 2013-10-11 11:11:11)
    

<@Lob>

- @Lob 어노테이션은 지정할 수 있는 속성이 없다.
- 매핑하는 필드 타입이 문자이면 ‘CLOB’으로, 나머지는 ‘BLOB’으로 매핑된다.
    - CLOB : String, char[], java.sql.CLOB
    - BLOB : byte[], java.sql.BLOB

<@Transient>

- 매핑하기 싫으면 @Transient 어노테이션을 쓰면 됨.

### 기본 키 매핑

- 기본 키 매핑에는 다음 두가지 어노테이션이 활용될 수 있다.
    - @Id : PK 값을 객체 생성할 때 직접 할당할 때 활용.
    - @GeneratedValue : 자동으로 PK 값이 설정되도록 설정. (MySQL의 AUTO INCREMENT)
    
    ```java
    @Id @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    ```
    
- @GeneratedValue : PK값 자동 생성.
- @GeneratedValue 의 strategy 속성
    - IDENTITY : DB에 위임. MYSQL
        - PK 생성을 DB에 맡기는 것. 대표적으로 MySQL의 AUTO INCREMENT
        - DB가 알아서 PK 값 정해주길 바람.
        
        ```java
        @Id
        @GeneratedValue(stategy = GenerationType.IDENTITY)
        private Long id;
        ```
        
    - SEQUENCE : DB 시퀀스 오브젝트 사용. ORACLE
        - @SequenceGenerator 필요
        - SEQUENCE도 유사하게 1부터 차례대로 유일한 값을 자동으로 저장한다.
        
        ```java
        @Entity
        @SequenceGenerator(
        		name = "MEMBER_SEQ_GENERATOR",
        		sequenceName = "MEMBER_SEQ", // 매핑할 DB 시퀀스 이름
        		initialValue = 1, allocationSize = 1)
        public class Member{
        	@Id
        	@GeneratedValue(strategy = GenerationType.SEQUENCE,
        				generator = "MEMBER_SEQ_GENERATOR")
        	private Long id;
        ...
        ```
        
        - 위 코드와 같이 @SequenceGenerator 어노테이션으로 Sequence를 직접 생성해서 엔티티와 매핑시켜도 됨. 이렇게 테이블마다 Sequence를 따로 관리하는게 더 좋음.
        - SequenceGenerator 안쓰면 hibernate가 자동으로 생성해줌
    - TABLE : 키 생성용 테이블을 사용. 모든 DB에서 사용
        - @TableGenerator 필요
        - 키를 생성하는 테이블을 아예 하나 만들어서 모든 DB에서 가져다 쓰는 방식.
        
        (Sequence와 유사한 방식이다.)
        
        - 모든 DB에서 적용이 가능하다는 장점이 있지만 테이블을 직접 사용하다보니 성능에 이슈가 있음.
        - 따라서 실제로 쓰기에는 조금 어려움이 있음.
    - AUTO : 방언에 따라 자동으로 지정. Default. 위 3가지 중에 사용되는 방언에 맞춰서 자동으로 설정된다.

### 권장하는 식별자 전략

- **기본 키 제약 조건** : null이 아니어야 함. 유니크해야함. **변하면 안됨.**
- 미래까지 해당 조건을 만족하는 자연키(주민번호, 폰번호 등)를 찾기는 어려움.
- 대리키(대체키)를 사용해야함. : AUTO INCREMENT나 랜덤 숫자 같이 **비즈니스와 전혀 상관없는 수**
- **권장 : 타입은 Long형으로,  대체키(identity, sequence 등) 활용, 적절한 키 생성전략 사용**
- 웬만하면 AUTO INCREMENT 혹은 SEQUENCE를 활용하자!

### IDENTITY 전략의 특징(단점?)

- IDENTITY 전략은 PK 값 설정을 DB에 아예 맡겨버리는 것이다.

→ 우리는 DB에 데이터가 저장되기 전까지 PK 값을 알 수 없다.

- 따라서 JPA 상에서 PK 값을 설정하지 않고 persist() 하게 되는데, 이렇게 되면 JPA 상에서 persist 하기 전까지 PK 값을 알 수 없게 된다.
- 그럼 영속성 컨텍스트에 저장될 때 PK 값과 함께 저장되어야 후에 활용할 수가 있는데, PK 값을 모르는 상태가 되어버린다.
- 이에따라 JPA는 JPA 상에서 PK값을 알 수 있도록 하기 위해 **IDENTITY 전략에 한해** persist() 하면 **바로 DB로 쿼리를 날리게 된다.**
    - persist() 하면 바로 DB에 쿼리 날리고, DB에 데이터가 저장되면서 PK 값이 결정되면 이를 다시 가져와 JPA 상에서 쓸 수 있도록 하는 것!
- IDENTITY 전략은 이렇게 동작 과정이 조금 꼬이는 단점이 있다.
    - persist()를 모아서 못하기도 하다.
    - 원래 JPA 동작 과정인 persist()를 모아서 commit() 할 때 한번에 보내는 것을 하지 못하고, persist() 하는 순간 바로 쿼리를 보내고, DB에서 결정된 PK를 다시 가져와 개발자가 활용할 수 있도록 한다.
    - **버퍼링을 못한다**
- 비약적인 문제는 없지만 그래도 알고는 있어야 한다.

### SEQUENCE 전략의 특징

- SEQUENCE 전략도 IDENTITY와 유사하게 DB가 PK를 관리하지만, **DB 내 SEQUENCE를 활용**한다는 차이가 있다.
- DB에는 테이블 외에도 PK를 관리해주는 SEQUENCE가 존재하며, 해당 Sequence에는 다음 부여할 PK 값이 저장되어 있다.
- 앞서 작성한 코드를 실행시키면 ‘MEMBER_SEQ’ 라는 이름의 Sequence가 DB에 생성된다.
    
    ```java
    @Entity
    @SequenceGenerator(
    				name = "MEMBER_SEQ_GENERATOR",
    				sequenceName = "MEMBER_SEQ",
    				initialValue = 1, allocationSize = 1)
    public class MEMBER{
    		@ID
    		@GeneratedValue(strategy = GenerationType.SEQUENCE,
    						generator = "MEMBER_SEQ_GENERATOR")
    		private Long id;
    ```
    
- SEQUENCE 전략에서는 persist() 를 하게 되면, IDENTITY 처럼 바로 DB에 저장하는게 아니라, DB의 Sequence에 다음 PK 값이 뭔지 물어보는 쿼리를 보내게 된다.
    - persist() 함수 호출
    - 전략이 SEQUENCE 임을 확인
    - DB에 해당 SEQUENCE의 다음 PK 값을 물어보는 쿼리 보냄
    - 다음 PK값을 알게 되면 이를 객체에 포함시켜서 영속성 컨텍스트에 저장함
- 따라서 SEQUENCE 전략은 IDENTITY와 달리 원래 JPA 동작 방식 그대로 persist()를 모아서 한번에 보낼 수가 있다.
- 버퍼링 가능!

### Sequence 전략, 최적화

- Sequence 전략에서 버퍼링이 가능하다고는 하지만, 그래도 persist() 할 때마다 DB와의 소통이 계속 이루어져야 한다.
- 이렇게 너무 불필요한 소통이 많은 것을 allocationSize를 조절해서 보완할 수 있다.

(allocationSize의 Default 값은 50이다)

```java
@Entity
@SequenceGenerator(name = "MEMBER_SEQ_GENERATOR", sequenceName = "MEMBER_SEQ", 
						initialValue = 1, allocationSize = 50)
public class Member{
		@Id
		@GenerateValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR")
		private Long id;
...
```

- 위 코드와 같이 allocationSize를 50으로 해두면, Memory 상에서 Sequence의 PK 값을 50개까지 저장해둔다는 의미이며, DB의 Sequence 값을 50씩 증가시킨다는 의미이다.
- 이는 아래와 같이 동작된다.
    - 처음 persist()를 만나면 DB와 소통해서 DB의 Sequence 값 1을 받고, 다시 한번 더 DB와 소통해서 DB의 Sequence 값을 51까지 올린다.
    - 그리고 이후에 persist()를 만나면 DB와 소통하지 않고 Memory 상에서 Sequence 값을 제공하게 된다.
    - 이후 Memory 상의 Sequence 값이 50에 다다르면, 이때 DB와 소통해서 DB의 Sequence 값을 101까지 올리고, Memory에서 51부터 100까지 또 제공하게 된다.
- 이렇게 되면 DB와의 불필요하게 잦은 소통을 줄일 수 있게 된다.
- 여기서 allocationSize를 너무 크게 잡아버리면, 애플리케이션을 내릴 일이 있을 때 Memory가 날아가기 때문에 그만큼 구멍이 생겨버린다.
- 따라서 allocationSize는 50~100 정도가 적당하다.

### 실전예제 적용

<실전 예제 전, 꿀팁 모음>

*팁 **“Command + N”** → GETTER, SETTER 한번에 다 만들 수 있음.

*관례상 네이밍 할 때, java는 camel Case로 많이 쓰고, DB는 언더바(_) 를 많이 쓰기 때문에, DB에 컬럼 만들 때 네이밍이 신경쓰인다 하면 그냥 무조건 @Column(name=”~~”) 으로 설정해주는게 속편하다.

*DB에 만들어질 때 아무 지정 안해주면 varchar(255) 처럼 Default로 정해지는데, 불편하면 @Column(length = ~) 와 같은 속성을 활용해서 설정해주면 된다.

*하지만 유지보수 측면, 혹은 팀단위 개발 측면에서 보면 @Column(~~) 으로 필요한 제약사항을 다 적어주는게 더 좋다.

→ 안그러면 JPA 개발할 때 계속 DB 내용 보려고 왔다갔다 해야함. 그냥 JPA 내에서 왔다갔다 하면서 보는게 더 수월하니까 정해져있는 제약사항들은 최대한 다 적어주는게 좋다.

*Spring Boot 에서는 java의 camel Case를 DB 관례에 맞춰서 자동으로 변환해주는 기능도 있다. 

⇒ orderDate → ORDER_DATE 혹은 order_date

<요구사항>

- 회원은 상품을 주문할 수 있다. : 회원, 사장 나뉨. 회원이 요청 보내면 사장에게 보여짐.
- 주문 시 여러 종류의 상품을 선택할 수 있다. : 상품 종류 나눠짐. enum으로? 각 필드별 가격까지?

<기능 목록>

- 회원 기능
    - 회원등록
    - 회원조회
- 상품 기능
    - 상품등록
    - 상품수정
    - 상품조회
- 주문 기능
    - 상품주문
    - 주문내역조회
    - 주문취소

<도메인 모델 분석>

- 회원 - 주문
    - 한명의 회원이 여러 번 주문할 수 있다.
    - 하나의 주문인데 여러 회원이 한 것으로 여길 순 없다. (한 회원마다 주문이 개별로 책정된다.)
    
    ⇒ 회원 : 주문 = 1 : N
    
- 주문 - 상품
    - 하나의 주문에 여러가지 상품이 선택될 수 있다.
    - 상품은 정해져있고, 그에 따른 여러 주문이 들어올 수 있다.
    
    → 주문 : 상품 = N : M
    
    - 이를 ‘주문상품’ 이라는 모델을 만들어 1 : N, N : 1 관계로 풀어낸다.
    
    → 주문 : 주문상품 = 1 : N, 주문상품 : 상품 = N : 1
    

<테이블 설계>

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%203.png)

- MEMBER 테이블 (회원)
    - MEMBER_ID (PK)
    - NAME
    - CITY
    - STREET
    - ZIPCODE
- ORDERS 테이블 (주문)
    - ORDER_ID (PK)
    - MEMBER_ID (FK) : 어느 회원이 주문했는지
    - ORDERDATE : 주문 날짜
    - STATUS : 상태
- ORDER_ITEM 테이블 (주문상품)
    - ORDER_ITEM_ID (PK)
    - ORDER_ID (FK) : 주문 번호
    - ITEM_ID (FK) : 상품 번호
    - ORDERPRICE : 가격
    - COUNT : 개수
- ITEM 테이블 (상품)
    - ITEM_ID (PK)
    - NAME :  상품명
    - PRICE : 가격
    - STOCKQUANTITY : 재고 수량

<테이블 설계에 따른 엔티티 설계와 매핑>

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%204.png)

- 위 엔티티 설계에 맞춰 JPA 내에 class를 생성하고, 매핑해주면 된다.

### 구현

<프로젝트 생성>

- 새로운 프로젝트를 생성한다. 이름 : jpashop
- pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>jpashop</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <!-- JPA 하이버네이트 -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>5.3.10.Final</version>
        </dependency>
        <!-- H2 데이터베이스 -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>1.4.200</version>
        </dependency>
        <!-- java 11 설정 -->
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.0</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

</project>
```

- project/src/main/resources/META-INF/persistence.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2"
             xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
    <persistence-unit name="jpashop">
        <properties>
            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/jpashop"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            <property name="hibernate.hbm2ddl.auto" value="create" />
        </properties>
    </persistence-unit>
</persistence>
```

- 디렉토리 생성
    - project/src/main/java/jpabook/jpashop/domain/
        - 해당 디렉토리 위치 안에 필요한 class들을 생성해준다.
    - project/src/main/java/jpabook/jpashop
        - 해당 디렉토리 위치 안에 Main class를 생성해준다.
        - project/src/main/java/jpabook/jpashop/JpaMain

<Member>

- project/src/main/java/jpabook/jpashop/domain/Member.java

```java
package jpabook.jpashop.domain;

import javax.persistence.*;

@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name="MEMBER_ID")
    private Long id;

    private String name;

    private String city;

    private String street;

    private String zipcode;

    //GETTER, SETTER
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }

    public String getZipcode() {
        return zipcode;
    }

    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }
}
```

- 우선은 PK 전략을 AUTO로 해두고 진행한다.
- JPA 내에서는 PK를 id로 쓰지만, DB의 컬럼에는 MEMBER_ID로 저장되어야 하기 때문에, @Column 어노테이션으로 이름을 설정해준다.
    - 아래 사진처럼 네이밍을 맞춰준다.
    
    ![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%203.png)
    

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%205.png)

<Order>

- project/src/main/java/jpabook/jpashop/domain/Order.java

```java
package jpabook.jpashop.domain;

import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name="ORDERS")
public class Order {

    @Id
    @GeneratedValue
    @Column(name="ORDER_ID")
    private Long id;

    @Column(name="MEMBER_ID")
    private Long memberId;

    private LocalDateTime orderDate;

    @Enumerated(EnumType.STRING)
    private OrderStatus status;

    public Long getId() {
        return id;
    }

    public Long getMemberId() {
        return memberId;
    }

    public LocalDateTime getOrderDate() {
        return orderDate;
    }

    public OrderStatus getStatus() {
        return status;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setMemberId(Long memberId) {
        this.memberId = memberId;
    }

    public void setOrderDate(LocalDateTime orderDate) {
        this.orderDate = orderDate;
    }

    public void setStatus(OrderStatus status) {
        this.status = status;
    }
}
```

- 여기서는 테이블 이름이 ORDERS가 되어야 하기 때문에 @Table 어노테이션으로 네이밍 해준다.
- 다른 네이밍들도 모두 맞춰준다.
- orderDate의 경우, @Temporal 어노테이션을 쓰지 않고 LocalDateTime 타입을 활용한다.
- OrderStatus는 enum 타입이므로 OrderStatus enum을 만들어준다.
    
    ```java
    package jpabook.jpashop.domain;
    
    public enum OrderStatus {
        ORDER, CANCEL
    }
    ```
    
    - 또한, 앞서 배웠던 것 처럼 EnumType.ORDINAL이 아닌, **EnumType.STRING** 을 쓴다.

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%206.png)

<OrderItem>

- project/src/main/java/jpabook/jpashop/domain/OrderItem.java

```java
package jpabook.jpashop.domain;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class OrderItem {
    @Id @GeneratedValue
    @Column(name = "ORDER_ITEM_ID")
    private Long id;

    @Column(name="ORDER_ID")
    private Long orderId;

    @Column(name="ITEM_ID")
    private Long itemId;

    private Integer orderPrice;

    private Integer count;

    public Long getId() {
        return id;
    }

    public Long getOrderId() {
        return orderId;
    }

    public Long getItemId() {
        return itemId;
    }

    public Integer getOrderPrice() {
        return orderPrice;
    }

    public Integer getCount() {
        return count;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setOrderId(Long orderId) {
        this.orderId = orderId;
    }

    public void setItemId(Long itemId) {
        this.itemId = itemId;
    }

    public void setOrderPrice(Integer orderPrice) {
        this.orderPrice = orderPrice;
    }

    public void setCount(Integer count) {
        this.count = count;
    }
}
```

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%207.png)

<Item>

- project/src/main/java/jpabook/jpashop/domain/Item.java

```java
package jpabook.jpashop.domain;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Item {

    @Id
    @GeneratedValue
    @Column(name="ITEM_ID")
    private Long id;

    private String name;

    private int price;

    private int stockQuantity;

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    public int getStockQuantity() {
        return stockQuantity;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public void setStockQuantity(int stockQuantity) {
        this.stockQuantity = stockQuantity;
    }
}
```

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%208.png)

<Main>

- project/src/main/java/jpabook/jpashop/JpaMain.java

```java
package jpabook.jpashop;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("jpashop");
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        EntityTransaction entityTransaction = entityManager.getTransaction();

        entityTransaction.begin();
        try {
            entityTransaction.commit();
        } catch (Exception e) {
            entityTransaction.rollback();
        } finally {
            entityManager.close();
        }

        entityManagerFactory.close();
    }

}
```

### 문제점

- 위와 같이 구성할 경우, FK에서 다음과 같은 문제가 발생한다.

예시)

<Order 엔티티>

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%209.png)

![Untitled](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20dd50bae946164458b85f75d0670e91ff/Untitled%203.png)

- 현재 위와 같이 ORDERS가 MEMBER_ID(FK)로 MEMBER의 MEMBER_ID(PK)를 가리키고 있다.
- 만약 JPA 개발 과정에서 주문한 회원에 대한 작업이 필요할 경우, 아래와 같이 수행되어야 한다.
    
    ```java
    try {
                Order order = entityManager.find(Order.class, 1L);
                Long memberId = order.getMemberId();
                Member member = entityManager.find(Member.class, memberId);
                
                ...
                
                entityTransaction.commit();
            } catch (Exception e) {
                entityTransaction.rollback();
            } finally {
                entityManager.close();
            }
    ```
    
    - 즉, Order 테이블에서 주문 정보를 가져오고, 그 주문을 했던 회원의 id값을 변수에 저장해 둔 후, 그 id값을 토대로 다시 한번 Member 테이블을 조회해야 진짜 그 Member의 정보를 가져올 수 있다.
    - 이는 아래와 같이 Order 내에 Member에 대한 정보를 DB 테이블 구성에 맞춰서 id로 저장하고 있기 때문이다.
    
    ```java
    		@Column(name="ORDER_ID")
        private Long id;
    
        @Column(name="MEMBER_ID")
        private Long memberId;
    ```
    
    - 이는 객체 위주(JPA 위주)의 개발이 아닌, 관계형 DB 위주의 개발인 것이다.
    
    (관계형 DB 형식에 객체를 맞춰서 개발하는 것!)
    
    - 이런식으로 개발하면 어려움이 많고, JPA 본 개념에서 벗어난 방식이다.
- 따라서 객체 위주의 개발을 하기 위해서는 Order 엔티티 내에 아래와 같은 형태로 Member 객체 자체를 두고 있어야 한다.
    
    ```java
    		@Column(name="ORDER_ID")
        private Long id;
    
        @Column(name="???")
        private Member member;
    ```
    
    - 이렇게 해두면 DB의 Order 테이블로부터 주문 정보를 가져온 후, 해당 주문을 했던 Member에 대한 작업을 할 때, 그 객체를 바로 가져올 수 있게 된다.
    - 이러한 작업을 하는게 **‘연관관계 매핑’** 인 것! 다음 시간부터 배운다.