# Section7

# 고급 매핑

<상속관계 매핑!>

- 상속관계 매핑
- @MappedSuperclass
- 실전 예제

### 상속관계 매핑

- 객체는 상속관계가 존재한다. 하지만 RDB에서는 상속관계를 지원하지 않음.
- 하지만 상속관계와 유사한 모델링 기법이 존재함 : 슈퍼타입 - 서브타입
    - 객체의 상속관계와 유사하다.
- 따라서 상속관계 매핑은 **객체의 상속 구조**와 **DB의 슈퍼타입-서브타입 관계**를 매핑하는 것이다.

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled.png)

- 왼편은 DB의 논리 모델에 해당한다.
    - 여기서 음반, 영화, 책은 모두 물품에 해당함.
    - 공통되는 분류를 묶어서 내릴 수 있음. : 물품(슈퍼타입) - 음반, 영화, 책(서브타입)
- 이는 객체의 상속관계와 유사함.
- 객체는 명확하게 상속관계를 갖는다. 오른편은 상속관계를 나타낸 것.
    - Item 이라는 추상 Type을 만들어두고, 이를 상속받는 Album, Movie, Book 이 있음.
    - 멤버 변수 및 함수를 상속받을 수 있다.

### 슈퍼타입-서브타입 논리모델 구현 방법 (DB)

- DB에서 슈퍼타입-서브타입 논리 모델을 실제 물리 모델로 구현하는 방법에는 3가지가 있다. (논리 → 물리로 실제 구현)
    
    → 조인 전략, 단일 테이블 전략, 구현 클래스마다 테이블 전략
    

**<조인 전략>**

- 슈퍼타입과 서브타입 모두 각각 테이블로 변환

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%201.png)

- 위 사진과 같이 ITEM, ALBUM, MOVIE, BOOK 테이블 모두 생성
- 논리 모델을 토대로 생각해보면, ALBUM, MOVIE, BOOK은 모두 ITEM의 필드를 활용할 수 있어야 함.
- 따라서 이 방법은 다음과 같이 구현된다. ALBUM 테이블을 예로 본다.
    - ALBUM은 ITEM의 NAME, PRICE 컬럼을 그대로 활용하고, 자신의 ARTIST 컬럼도 활용할 수 있어야 한다. : ALBUM이 활용할 수 있는 컬럼 : NAME, PRICE, ARTIST
        - MOVIE와 BOOK도 동일하게 ITEM의 컬럼과 본인의 컬럼을 쓸 수 있어야 한다.
    - 따라서 ITEM을 슈퍼타입 테이블로 두고, 나머지는 서브타입 테이블로 만든 후, FK를 둬서 join 시킨다.
        - ALBUM에 해당하는 데이터를 넣을 때, ALBUM과 ITEM 둘에 나눠서 넣는다.
    - join할 때는 ALBUM의 FK 값(ITEM_ID)을 토대로 묶어서 조회한다.
    - ITEM 테이블 내에서도 각 데이터들이 어느 서브타입에 해당하는지 저장해두어야 하기 때문에 ‘DTYPE’ 컬럼을 두고, 해당 컬럼에서 ALBUM, MOVIE, BOOK을 구분한다.

**<단일 테이블 전략>**

- 논리 모델 자체를 아예 하나의 테이블로 통합시켜버림.

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%202.png)

- 논리 모델에 해당하는 모든 컬럼들을 ITEM 이라는 테이블 하나에 다 때려박음.
- ‘DTYPE’으로 각각 ALBUM, MOVIE, BOOK 중 어느 것인지 구분.

**<구현 클래스마다 테이블 전략>**

- 슈퍼타입의 컬럼이 서브타입 테이블에서 모두 중복되더라도 그냥 서브타입 테이블에 모두 포함시킴

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%203.png)

- 슈퍼타입(ITEM)의 컬럼을 서브타입(ALBUM,MOVIE,BOOK)들 모두 갖고 있는 형태.
- 그냥 중복되는걸 하나로 안합치고 각자 갖고 있는 것.

- DB에서는 이렇게 3가지 방식으로 나뉘어지지만, 객체는 그냥 상속 관계 쓰면 됨. DB에서 3가지 방식 중 어느 것을 선택하더라도 객체 입장에서는 모두 가능하다. 3가지 방식 중 어느 것으로 할지 선택해야함.

⭐ **JPA에서 구현할 때, Item 클래스를 추상 클래스로 만들어야 함.** ⭐

- 아래 예시 코드에서는 추상클래스로 안되어 있는데, 원래는 추상으로 해야함.

### 상속관계 매핑 방법 - 조인 전략

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%201.png)

- 조인 전략은 **데이터를 가장 정규화 시켜서 깔끔, 정돈되게 저장**할 수 있음.
- JPA에서 **객체의 상속관계와도 가장 유사한 모델**이 만들어진다.
- **@Inheritance(strategy = InheritanceType.JOINED)**

<구현>

- Item, Album, Movie, Book class 생성
    - Item class 생성
    
    ```java
    @Entity
    public class Item{
    	@Id @GeneratedValue
    	@Column(name = "ITEM_ID")
    	private Long id;
    
    	private String name;
    	private int price;
    }
    ```
    
    - Album class 생성
    
    ```java
    @Entity
    public class Album extends Item{
    	private String artist;
    }
    ```
    
    - Movie class 생성
    
    ```java
    @Entity
    public class Movie extends Item{
    	private String director;
    	private String actor;
    }
    ```
    
    - Book class 생성
    
    ```java
    @Entity
    public class Book extends Item{
    	private String author;
    	private String isbn;
    }
    ```
    
- Item class

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Item{
...
```

- 이렇게 @Inheritance 어노테이션에 strategy 속성을 ‘InheritanceType.JOINED’ 로 설정하면, 조인 전략으로 DB가 설정된다.

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%204.png)

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%201.png)

- 이렇게 구현해놓고 데이터를 저장해보면 다음과 같이 동작한다.

```java
						Movie movie = new Movie();
            movie.setDirector("aaa");
            movie.setActor("bbb");
            movie.setName("cccc");
            movie.setPrice(10000);
            em.persist(movie);
```

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%205.png)

- 위 사진과 같이 insert 쿼리가 Item과 Movie에 나가는 것을 확인할 수 있다.
- 조회할 때도 다음과 같이 동작한다.

```java
						Movie movie = new Movie();
            movie.setDirector("aaa");
            movie.setActor("bbb");
            movie.setName("cccc");
            movie.setPrice(10000);
            em.persist(movie);

	          em.flush();
	          em.clear();

	          Movie findMovie = em.find(Movie.class, movie.getId());
```

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%206.png)

- 위 사진과 같이 ITEM, MOVIE 테이블을 조인해서 조회하는 것을 확인할 수 있다.

- 근데 위 과정에서는 ITEM 테이블 내에 ‘DTYPE’ 컬럼이 생략되어 있는 것을 볼 수 있다.
- ‘DTYPE’ 컬럼을 통해 ITEM 테이블 내에서도 구분을 짓기 위해서는 **@DiscriminatorColumn** 어노테이션을 추가해주어야 한다.

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item{
...
```

- 해당 어노테이션을 추가해놓고 다시 실행해보면, 아래와 같이 ‘DTYPE’ 컬럼이 추가되는 것을 확인할 수 있다.

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%207.png)

- @DiscriminatorColumn 에 아무 속성도 설정하지 않으면, 저장되는 데이터 값으로 엔티티 이름이 들어간다. : Movie, Album, Book
    - 컬럼 명을 DTYPE 말고 다른걸로 바꾸고 싶으면 name 속성을 쓰면 된다.
    
    ```java
    @DiscriminatorColumn(name = "~~")
    ```
    
    - 만약 저장되는 데이터 값을 바꾸고 싶을 경우, (Movie, Album, Book 말고 다른걸로)
        
        상속받는 엔티티에 각각 @DiscriminatorValue 어노테이션으로 설정해주어야 한다.
        
    - Movie → M 으로 저장되길 원하면 아래와 같이 설정하면 된다.
    
    ```java
    @Entity
    @DiscriminatorValue("M")
    public class Movie extends Item{
    	...
    ```
    
    ![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%208.png)
    
- **@DiscriminatorColumn 어노테이션은 웬만하면 추가해주는게 좋다.** 운영 과정에서 ITEM 테이블 내에 어떤 엔티티의 데이터인지 구분할 수 있는게 좋음.

### 상속관계 매핑 방법 - 단일 테이블 전략

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%209.png)

- 만약 조인 전략이 너무 복잡해보이고, 굳이 그렇게 안하고 하나의 테이블로 하길 원할 경우, 단일 테이블 전략을 활용할 수 있다.
    - 그냥 한 테이블에 다 때려박고 ‘DTYPE’ 으로 구분하는 것.
- 사실 아무 설정도 안하고 JPA에서 상속 관계만 명시해두면 단일 테이블 전략으로 설정된다.
    - 아무 설정 안하는 과정
        - Item class 생성
        
        ```java
        @Entity
        public class Item{
        	@Id @GeneratedValue
        	@Column(name = "ITEM_ID")
        	private Long id;
        
        	private String name;
        	private int price;
        }
        ```
        
        - Album class 생성
        
        ```java
        @Entity
        public class Album extends Item{
        	private String artist;
        }
        ```
        
        - Movie class 생성
        
        ```java
        @Entity
        public class Movie extends Item{
        	private String director;
        	private String actor;
        }
        ```
        
        - Book class 생성
        
        ```java
        @Entity
        public class Book extends Item{
        	private String author;
        	private String isbn;
        }
        ```
        
        - 실행 결과
        
        ![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%2010.png)
        
- 제대로 하는 법은 앞서 조인 전략 코드에서 그냥 strategy 값만 바꿔주면 된다.
    - 조인 전략 : @Inheritance(strategy = InheritanceType.JOINED)
    - 단일 테이블 전략 : @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    - **분명 DB 구조는 완전히 달라지는데, JPA 에서는 다른거 다 안건들고 코드 한줄만 바꿔주면 된다. 매우 큰 장점이다!**

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Item{
...
```

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%2011.png)

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%2012.png)

- DDL과 insert, select 쿼리 모두 하나씩만 나가기 때문에 성능적으로 가장 잘 나오는 방식이기도 하다.
- 또한, 단일 테이블 전략의 경우, @DiscriminatorColumn 어노테이션을 생략해도 ‘DTYPE’ 컬럼이 자동으로 생성된다.
    - 조인 전략의 경우, 테이블 자체가 나눠져있고, FK로 연결되어 있기 때문에 DTYPE 컬럼이 없어도 찾을 순 있다.
    - 하지만 단일 테이블 전략의 경우, 테이블 하나에 다 때려박고 DTYPE으로 구분해야 하기 때문에, 무조건 있어야 하는 컬럼이다.
    
    → **따라서 InheritanceType.SINGLE_TABLE은 @DiscriminatorColumn 어노테이션을 생략해도 DTYPE 컬럼이 필수이기 때문에 자동으로 추가된다.**
    
- 하지만 조인 전략에서도 DTYPE은 추가해주는게 좋다.

### 상속관계 매핑 방법 - 구현 클래스마다 테이블 전략

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%203.png)

- 위 사진과 같이 각 테이블마다 중복되더라도 그냥 서브타입 테이블만 생성하는 방식이다.
- 여기서도 다음과 같이 그냥 InheritanceType만 바꿔주면 된다.
    - 여기서, @DiscriminatorColumn과 @DiscriminatorValue 어노테이션은 지워도 된다.
        
        (써도 무시된다.)
        
    - 어차피 서브타입 테이블에 슈퍼타입 테이블의 컬럼들이 중복돼서 다 들어가기 때문에, 구분 컬럼을 넣을 필요가 없다.

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item{
...
```

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%2013.png)

- 위 사진과 같이 ITEM의 컬럼들(ITEM_ID, NAME, PRICE)이 서브타입 테이블에 각각 중복되어 들어가는 것을 확인할 수 있다.
- 이 방법도 괜찮아 보이지만, 사실 가장 큰 문제가 있다.
- 만약 ITEM_ID, NAME, PRICE 정보만 알고 있는 상태에서 특정 Movie를 조회해야 하는 경우, 굉장히 난감해진다. **(슈퍼타입 컬럼들을 기준으로 조회해야 하는 경우에 해당한다.)**
- 이 경우 ITEM_ID, NAME, PRICE 정보에 맞는 데이터들을 ALBUM, MOVIE, BOOK 모든 테이블을 대상으로 탐색해야 한다.

```java
Item item = em.find(Item.class, movie.getId());
```

- 만약 위와 같이 코드를 짜게 되면, 아래와 같이 쿼리가 union까지 써가면서 복잡해진다.
- 실행된 쿼리문
    
    ```sql
    select
            item0_.ITEM_ID as item_id1_2_0_,
            item0_.name as name2_2_0_,
            item0_.price as price3_2_0_,
            item0_.arist as arist1_0_0_,
            item0_.author as author1_1_0_,
            item0_.isbn as isbn2_1_0_,
            item0_.actor as actor1_6_0_,
            item0_.director as director2_6_0_,
            item0_.clazz_ as clazz_0_ 
        from
            ( select
                ITEM_ID,
                name,
                price,
                arist,
                null as author,
                null as isbn,
                null as actor,
                null as director,
                1 as clazz_ 
            from
                Album 
            union
            all select
                ITEM_ID,
                name,
                price,
                null as arist,
                author,
                isbn,
                null as actor,
                null as director,
                2 as clazz_ 
            from
                Book 
            union
            all select
                ITEM_ID,
                name,
                price,
                null as arist,
                null as author,
                null as isbn,
                actor,
                director,
                3 as clazz_ 
            from
                Movie 
        ) item0_ 
    where
        item0_.ITEM_ID=?
    ```
    

### 전략별 장단점

- 우선 ‘구현 클래스마다 테이블 전략’ 은 버리는게 좋다.
- ⭐ **조인 전략 vs 단일 테이블 전략 둘 중에 하나를 DBA와 함께 고르는게 좋다.** ⭐
- **보통은 조인 전략을 기본적으로 쓰고, 진짜 너무 단순한 모델인 경우에 단일 테이블 전략을 쓰는게 좋다.**

**<조인 전략>**

- 장점
    - **일단 조인 전략이 상속관계 매핑 전략들 중 가장 정석이라고 볼 수 있다.**
    - 테이블이 정규화 되어 있다.
    - FK 참조 무결성 제약조건을 활용할 수 있다.
        - 위 예제에서 ITEM 테이블의 ITEM_ID와 MOVIE 테이블의 ITEM_ID가 동일한 값을 갖는다.
        - 따라서 만약 특정 Movie 데이터 중, ITEM 테이블에 있는 정보만 조회해야 한다면, 다른 테이블들 볼 필요 없이 ITEM 테이블에서 ITEM_ID 값만 갖고 조회가 가능하다.
    - 저장 공간의 효율화가 가능하다.
        - 테이블이 정규화 되어 있기 때문에 저장 공간 활용 자체가 효율적이다.
- 단점
    - 조회 시 join을 많이 사용한다. 성능이 저하될 수 있다.
        - 하지만 join도 잘 맞추면 성능이 저하되지 않고, 일단 저장공간에서 효율성을 가져가기 때문에 성능이 더 좋아질 수도 있다.
    - 조회 쿼리가 복잡하다.
    - 데이터 저장할 때, 슈퍼타입, 서브타입 각각 나눠서 저장해야 되므로 INSERT 쿼리가 2번 나간다.
    - 사실 이런 내용들이 큰 단점은 아니지만, 단일 테이블과 비교해보면 많이 복잡하다는 것 자체가 일단 하나의 단점이 될 수 있다.

**<단일 테이블 전략>**

- 장점
    - join이 필요가 없으므로, 일반적으로 조회 성능이 빠르다.
    - 조회 쿼리가 단순하다.
- 단점
    - 자식 엔티티가 매핑한 컬럼들은 모두 null이 허용되어야 한다. (치명적이다)
        - 만약 Movie 데이터가 들어가면, 나머지 Album, Book 테이블에 해당하는 컬럼들은 모두 null 이 들어가야 하기 때문에.
    - 단일 테이블에 모든 것을 저장하기 때문에, 오히려 테이블이 매우 커질 수 있고, 상황에 따라서 조회 성능이 오히려 느려질 수도 있다.
        - 하지만 일반적으로는 성능이 빠르다.
    

**<구현 클래스마다 테이블 전략>**

- 이 전략은 일단 쓰면 안된다.
    - 객체지향 개발자와 DB 개발자 양쪽 모두 싫어하는 방식의 개발법이다.
    - 중복되는 내용이 묶이는게 아무것도 없음.
- 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적이다.
    - not null 제약조건을 사용할 수 있다.
        - 어차피 서브타입 테이블 모두 필요한 모든 컬럼들을 다 갖고 있기 때문에.
- 단점
    - 여러 자식 테이블들을 함께 조회할 때 성능이 느리다.(쿼리에서 UNION이 활용되어서)
    - 자식 테이블을 통합해서 쿼리하기 어렵다.
    

### @MappedSuperclass

- 상속관계 매핑과는 큰 관련은 없음.
- **실무에서 많이 쓰인다.**

![Untitled](Section7%20cd012e81adce4fa7bfdaefe82fcd4346/Untitled%2014.png)

- 위 사진과 같이, 객체에서 특정 필드가 너무 자주 나올 경우, 부모 엔티티에 공통 필드 넣어두고 상속받아서 쓰고 싶은 경우에 대한 개념이다.
- DB에는 반영되지 않는다.
- 객체의 id, name 과 같은 필드들은 거의 모든 엔티티들이 갖고 있는 것이므로, 이를 매번 반복해서 적기보다 한 곳에 몰아두고 받아서 쓰는 느낌으로 보면 될 듯 하다.
- 공통 매핑 정보(id, name)가 필요할 때, 귀찮음을 줄이기 위해 쓰인다.

**<예시 설정>**

- 만약 모든 엔티티에 등록자, 등록일자, 수정자, 수정일자를 다음과 같이 추가해야 한다고 가정한다.

```java
private String createdBy;
private LocalDateTime createdDate;
private String lastModifiedBy;
private LocalDateTime lastModifiedDate;
```

- 이를 모든 엔티티에 다 복붙할 수는 없다. (할 수 있지만 매우 귀찮을 것이다.)
- 이럴 때 @MappedSuperclass 어노테이션을 활용할 수 있다.
    - 프론트에서 기본 레이아웃을 전체 파일에 다 깔아주는 것과 비슷한 느낌인 듯 하다.

- 우선 [BaseEntity.java](http://BaseEntity.java) 클래스를 생성하고, @MappedSuperclass 어노테이션을 추가한 후, 필요한 필드와 GETTER SETTER를 넣어준다.

```java
@MappedSuperclass
public abstract class BaseEntity{
	private String createdBy;
	private LocalDateTime createdDate;
	private String lastModifiedBy;
	private LocalDateTime lastModifiedDate;

...
}
```

- 그리고 해당 필드들이 필요한 엔티티에서 이를 상속받으면 된다.

```java
...
public class Member extends BaseEntity{
...
```

- 그럼 상속받은 엔티티들 모두 BaseEntity의 필드들을 본인만의 필드로 갖게 된다.
- ⭐ **그냥 많이 중복되는 기본적인 필드들을 기본으로 깔고 싶을 때 해당 기능을 활용하면 된다.** ⭐

### @MappedSuperclass 특징

- 앞서 다루었던 상속관계 매핑이 아니다. 그냥 JPA 내에서만 귀찮음을 줄여줄 수 있는 기능인 것.
- 해당 어노테이션을 붙인 클래스는 엔티티가 아니다. 따라서 테이블과 매핑되지 않는다.
    - @Entity를 안붙였으므로
- 부모 클래스(BaseEntity)를 상속 받는 자식 클래스(Member)에게 매핑 정보만 제공해 주는 것이다.
    - 그냥 필드들 제공해주고 테이블과 매핑만 시켜주는 것.
- 조회, 검색이 불가능하다.
    - em.find(BaseEntity…) 안된다.
- **객체를 직접 만들어서 사용할 일이 없으므로 웬만하면 추상 클래스로 만드는게 좋다.**
    
    ```java
    @MappedSuperclass
    public abstract class BaseEntity{
    ...
    ```
    
- DB 테이블과 관계 없다. 단순히 **여러 엔티티가 공통으로 사용하는 매핑 정보를 한 곳에 모아주는 역할**만 해주는 것.
- 주로 등록일, 수정일, 등록자, 수정자 등과 같이 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용된다.
- 참고사항 : @Entity 어노테이션이 적용된 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 받을 수 있다.
    - JPA 안에서는 @Entity나 @MappedSuperclass 가 적용되어 있는 클래스로부터만 상속을 받을 수 있다.

### 실전 예제

- 상품의 종류는 음반, 도서, 영화가 있고, 이후 더 확장될 수 있다. : 상속관계 매핑
    - 예제에서는 단일 테이블로 설정.
- 모든 데이터는 등록일과 수정일이 필수이다. : @MappedSuperclass
-